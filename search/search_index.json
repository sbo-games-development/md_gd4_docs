{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MD_GD4_DOCS","text":"<p>Create Markdown documentation files automatically from Godot 4 projects/docstrings.</p> <p>The full source code can be found at md_gd4_docs - GitHub.com</p> <p>The documentation is split in 2 Parts:</p> <ul> <li>User documentation: How to install and use the application.</li> <li>Project documentation: Documentation of the project and the source code.</li> </ul>"},{"location":"src/","title":"app.py","text":"<p>An application to create Markdown documentation files automatically from Godot 4 projects/docstrings.</p> <p>The full source code can be found at md_gd4_docs - GitHub.com</p>"},{"location":"src/#src.app.Main","title":"<code>Main</code>","text":"<p>Main entry point of the application</p> <p>Attributes:</p> Name Type Description <code>version</code> <code>str</code> <p>Version of the application, also shown in the help</p> <p>Returns:</p> Name Type Description <code>Application_exit_code</code> <code>int</code> <p>0 = success | 2 = argument parsing error | 5 = input/output error | and more?</p> Source code in <code>src/app.py</code> <pre><code>class Main:\n    \"\"\"\n    Main entry point of the application\n\n    Attributes:\n        version: Version of the application, also shown in the help\n\n    Returns:\n        Application_exit_code (int): 0 = success | 2 = argument parsing error | 5 = input/output error | and more?\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Constructor of the applications Main class.\n\n        Depending on command line args, either initializes the settings or build markdown files as configured in\n        the settings file.\n        \"\"\"\n        self.version: str = \"0.1.0\"\n        args: argparse.Namespace = self.arg_parse_init()\n        settings: Settings = Settings()\n        if args.init:\n            result: bool = settings.init_settings()\n        elif args.build:\n            result: bool = settings.load_settings()\n            if result:\n                Build(settings.get_settings(), settings.doc_conf_file)\n                # todo: Build addons/plugins might be handled here later ...\n        else:\n            print(\"Something went very wrong ...\")\n            result: bool = False\n        if result:\n            exit(0)\n        else:\n            exit(5)\n\n    def arg_parse_init(self):\n        \"\"\"\n        Parses and returns the command line arguments.\n\n        Sets init (-i/--init) or build (-b/--build) to True, shows the help (-h/--help) or the version (-v/--version).\n        If none of the former applies, an error message wil be displayed.\n        \"\"\"\n        parser = argparse.ArgumentParser(\n            prog=\"md_gd4_docs\",\n            description=\"Create Markdown documentation files automatically from Godot 4 projects/docstrings\",\n            epilog=\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n        )\n        group = parser.add_mutually_exclusive_group(required=True)\n        group.add_argument(\n            \"-i\", \"--init\", action=\"store_true\",\n            help=\"Creates a settings template (./md_gd4_docs.yml)\"\n        )\n        group.add_argument(\n            \"-b\", \"--build\", action=\"store_true\",\n            help=\"Creates the documentation files following the settings file ./md_gd4_docs.yml\"\n        )\n        group.add_argument(\n            \"-v\", \"--version\", action=\"version\", version=f\"%(prog)s {self.version}\",\n            help=\"Shows the version of the application\"\n        )\n        return parser.parse_args()\n</code></pre>"},{"location":"src/#src.app.Main.__init__","title":"<code>__init__()</code>","text":"<p>Constructor of the applications Main class.</p> <p>Depending on command line args, either initializes the settings or build markdown files as configured in the settings file.</p> Source code in <code>src/app.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor of the applications Main class.\n\n    Depending on command line args, either initializes the settings or build markdown files as configured in\n    the settings file.\n    \"\"\"\n    self.version: str = \"0.1.0\"\n    args: argparse.Namespace = self.arg_parse_init()\n    settings: Settings = Settings()\n    if args.init:\n        result: bool = settings.init_settings()\n    elif args.build:\n        result: bool = settings.load_settings()\n        if result:\n            Build(settings.get_settings(), settings.doc_conf_file)\n            # todo: Build addons/plugins might be handled here later ...\n    else:\n        print(\"Something went very wrong ...\")\n        result: bool = False\n    if result:\n        exit(0)\n    else:\n        exit(5)\n</code></pre>"},{"location":"src/#src.app.Main.arg_parse_init","title":"<code>arg_parse_init()</code>","text":"<p>Parses and returns the command line arguments.</p> <p>Sets init (-i/--init) or build (-b/--build) to True, shows the help (-h/--help) or the version (-v/--version). If none of the former applies, an error message wil be displayed.</p> Source code in <code>src/app.py</code> <pre><code>def arg_parse_init(self):\n    \"\"\"\n    Parses and returns the command line arguments.\n\n    Sets init (-i/--init) or build (-b/--build) to True, shows the help (-h/--help) or the version (-v/--version).\n    If none of the former applies, an error message wil be displayed.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"md_gd4_docs\",\n        description=\"Create Markdown documentation files automatically from Godot 4 projects/docstrings\",\n        epilog=\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\n        \"-i\", \"--init\", action=\"store_true\",\n        help=\"Creates a settings template (./md_gd4_docs.yml)\"\n    )\n    group.add_argument(\n        \"-b\", \"--build\", action=\"store_true\",\n        help=\"Creates the documentation files following the settings file ./md_gd4_docs.yml\"\n    )\n    group.add_argument(\n        \"-v\", \"--version\", action=\"version\", version=f\"%(prog)s {self.version}\",\n        help=\"Shows the version of the application\"\n    )\n    return parser.parse_args()\n</code></pre>"},{"location":"src/control/build/","title":"build.py","text":""},{"location":"src/control/build/#src.control.build.Build","title":"<code>Build</code>","text":"<p>Reads the necessary data from the project and source files and generates the markdown documentation file(s) from it.</p> <p>Attributes:</p> Name Type Description <code>doc_conf_data</code> <code>CommentedMap</code> <p>The deserialized settings for reading the sourcecode</p> <code>doc_conf_file</code> <code>str</code> <p>Path to the documentation config file</p> <code>gd_project</code> <code>dict</code> <p>For information extracted from project.godot file</p> <code>doc_data</code> <code>list[ClassDoc]</code> <p>For information extracted from script files classes</p> <code>script_files</code> <code>dict</code> <p>A dictionary with information for all script files in the project and/or in the filelist_scan scan_list</p> <code>scene_files</code> <code>list</code> <p>A list for all scene files of the project</p> <p>doc_conf_data attributes:</p> Name Type Description <code>doc_destination</code> <code>str</code> <p>Destination directory for the resulting documentation. Create if not exists</p> <code>rebuild_src_path</code> <code>bool</code> <p>Reproduces directories from src_path for doc_destination if True</p> <code>project_scan</code> <code>bool</code> <p>Scanning all files of a project if True</p> <code>project_scan_options</code> <code>list[dict]</code> <p>Mandatory if project_scan is True</p> <code>filelist_scan</code> <code>bool</code> <p>Scanning a manually created list if True, can be combined with project_scan to add more files to scan</p> <code>scan_list</code> <code>list</code> <p>List to be scanned if filelist_scan is True</p> <p>doc_conf_data.project_scan_options attributes</p> Name Type Description <code>src_path</code> <code>str</code> <p>The base directory of the project to scan</p> <code>read_gd_project(bool)</code> <code>str</code> <p>Creates a project documentation index if True</p> <code>scene2src_links</code> <code>bool</code> <p>Scans and documents if a script is linked to a scene</p> <p>gd_project attributes:</p> Name Type Description <code>project_name</code> <code>str</code> <p>For the name of the godot project, as read from the project.godot file</p> <code>godot_version</code> <code>str</code> <p>For the godot version of the godot source code, as read from the project.godot file</p> <code>main_scene</code> <code>str</code> <p>For the data of the main (aka starting) scene, as read from the project.godot file</p> <code>autoload</code> <code>list[dict]</code> <p>Scenes that load at application start, if enabled</p> <p>gd_project.main_scene attributes:</p> Name Type Description <code>scene_path</code> <code>str</code> <p>For the path to the main (aka starting) scene, as read from the project.godot file</p> <code>added_script</code> <code>str</code> <p>The script linked to the main scene, if any</p> <p>gd_project.autoload list[dict] attributes:</p> Name Type Description <code>scene_path</code> <code>str</code> <p>For the path to the scene, as read from the project.godot file</p> <code>added_script</code> <code>str</code> <p>The script linked to the scene, if any</p> <code>enabled</code> <code>bool</code> <p>Is the autoload scene enabled?</p> <p>script_files attributes:</p> Name Type Description <code>scene</code> <code>str</code> <p>Full path to the connected scene, if any</p> <code>docs</code> <code>list</code> <p>For elements from docstring reading</p> <p>Returns:</p> Name Type Description <code>Application_exit_code</code> <code>int</code> <p>Applications exits directly from this class on error. if anything is successful, returns None to the calling Main class. This gives the possibility for working with addons there after the creation of the documentation files (for example creating a full site including menus with mkdocs)</p> Source code in <code>src/control/build.py</code> <pre><code>class Build:\n    \"\"\"\n    Reads the necessary data from the project and source files and generates the markdown documentation file(s) from it.\n\n    Attributes:\n        doc_conf_data: The deserialized settings for reading the sourcecode\n        doc_conf_file: Path to the documentation config file\n        gd_project: For information extracted from project.godot file\n        doc_data: For information extracted from script files classes\n        script_files: A dictionary with information for all script files in the project and/or in the filelist_scan\n            scan_list\n        scene_files: A list for all scene files of the project\n\n    Attributes: doc_conf_data attributes:\n        doc_destination (str): Destination directory for the resulting documentation. Create if not exists\n        rebuild_src_path (bool): Reproduces directories from src_path for doc_destination if True\n        project_scan (bool): Scanning all files of a project if True\n        project_scan_options (list[dict]): Mandatory if project_scan is True\n        filelist_scan (bool): Scanning a manually created list if True, can be combined with project_scan to add more\n            files to scan\n        scan_list (list): List to be scanned if filelist_scan is True\n\n    Attributes: doc_conf_data.project_scan_options attributes\n        src_path (str): The base directory of the project to scan\n        read_gd_project(bool): Creates a project documentation index if True\n        scene2src_links (bool): Scans and documents if a script is linked to a scene\n\n    Attributes: gd_project attributes:\n        project_name (str): For the name of the godot project, as read from the project.godot file\n        godot_version (str): For the godot version of the godot source code, as read from the project.godot file\n        main_scene (str): For the data of the main (aka starting) scene, as read from the project.godot file\n        autoload (list[dict]): Scenes that load at application start, if enabled\n\n    Attributes: gd_project.main_scene attributes:\n        scene_path (str): For the path to the main (aka starting) scene, as read from the project.godot file\n        added_script (str): The script linked to the main scene, if any\n\n    Attributes: gd_project.autoload list[dict] attributes:\n        scene_path (str): For the path to the scene, as read from the project.godot file\n        added_script (str): The script linked to the scene, if any\n        enabled (bool): Is the autoload scene enabled?\n\n    Attributes: script_files attributes:\n        scene (str): Full path to the connected scene, if any\n        docs (list): For elements from docstring reading\n\n    Returns:\n        Application_exit_code (int): Applications exits directly from this class on error. if anything is successful,\n            returns None to the calling Main class. This gives the possibility for working with addons there after the\n            creation of the documentation files (for example creating a full site including menus with mkdocs)\n    \"\"\"\n    def __init__(self, doc_conf_data: CommentedMap, doc_conf_file: str):\n        \"\"\"\n        Constructor of the class. Anything from reading project to building documentation sites is done from here.\n\n        Args:\n            doc_conf_data: The deserialized settings for reading the sourcecode\n            doc_conf_file: Path to the documentation config file\n        \"\"\"\n        self.doc_conf_data: CommentedMap = doc_conf_data\n        self.doc_conf_file: str = doc_conf_file\n        self.gd_project: dict = {\n            \"project_name\": \"\",\n            \"godot_version\": \"\",\n            \"main_scene\": {\n                \"scene_path\": \"\",\n                \"added_script\": \"\"\n            },\n            \"autoload\": []\n        }\n        self.doc_data: list[ClassDoc] = []\n        self.script_files: dict = {}\n        self.scene_files: list = []\n        self.check_doc_conf_data()\n        print(f\"Check of {self.doc_conf_file} configuration file finished, everything seems ok\")\n        if self.doc_conf_data[\"project_scan\"]:\n            self.collect_proj_files_info()\n            if self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"]:\n                self.connect_scene_to_script()\n            self.scan_project_scripts()\n\n        #\n\n    def check_doc_conf_data(self):\n        \"\"\"\n        Checks if the configuration data are correct. Exits directly after printing error message if not.\n        \"\"\"\n        # todo: point to according chapter/subsite in error msgs urls?\n        print(\"Checking settings correctness before reading &amp; building ...\")\n        # print(self.doc_conf_data)\n        if \"doc_destination\" not in self.doc_conf_data or self.doc_conf_data[\"doc_destination\"] == \"\" \\\n                or not isinstance(self.doc_conf_data[\"doc_destination\"], str):\n            print(f\"doc_destination not set in {self.doc_conf_file}, empty or wrong type\")\n            print()\n            print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n            exit(5)\n        if \"rebuild_src_path\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"rebuild_src_path\"], bool):\n            print(f\"rebuild_src_path not set in {self.doc_conf_file} or wrong type\")\n            exit(5)\n        if \"project_scan\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"rebuild_src_path\"], bool):\n            print(f\"project_scan not set in {self.doc_conf_file} or wrong type\")\n            print()\n            print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n            exit(5)\n        if self.doc_conf_data[\"project_scan\"]:\n            if \"project_scan_options\" not in self.doc_conf_data \\\n                    or not isinstance(self.doc_conf_data[\"project_scan_options\"], CommentedMap):\n                print(f\"project_scan_options not set in {self.doc_conf_file}, wrong type or empty\")\n                print(\"project_scan_options are needed if project_scan is true\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if \"src_path\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                    or self.doc_conf_data[\"project_scan_options\"][\"src_path\"] == \"\"\\\n                    or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], str):\n                print(f\"src_path wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n                exit(5)\n            if self.doc_conf_data[\"project_scan_options\"][\"src_path\"] == self.doc_conf_data[\"doc_destination\"]:\n                print(f\"Conflicting options: src_path in project_scan_options can't be the same as doc_destination in \"\n                      f\"{self.doc_conf_file} settings file\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if \"read_gd_project\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                    or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"read_gd_project\"], bool):\n                print(f\"read_gd_project wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if \"scene2src_links\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                    or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"], bool):\n                print(f\"scene2src_links wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if not isdir(self.doc_conf_data[\"project_scan_options\"][\"src_path\"]):\n                print(f\"src_path in project_scan_options in {self.doc_conf_file} doesn't exist\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(2)\n        if \"filelist_scan\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"filelist_scan\"], bool):\n            print(f\"filelist_scan not set in {self.doc_conf_file} or wrong type\")\n            print()\n            print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n            exit(5)\n        if not self.doc_conf_data[\"project_scan\"] and not self.doc_conf_data[\"filelist_scan\"]:\n            print(f\"At least one of the options project_scan or filelist_scan needs to be set true, otherwise theres \"\n                  f\"nothing to scan\")\n            print()\n            print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n            exit(5)\n        if self.doc_conf_data[\"filelist_scan\"]:\n            if \"scan_list\" not in self.doc_conf_data \\\n                    or not isinstance(self.doc_conf_data[\"scan_list\"], CommentedSeq):\n                print(f\"scan_list not set in {self.doc_conf_file}, wrong type or empty\")\n                print(\"scan_list is needed if filelist_scan is true\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if len(self.doc_conf_data[\"scan_list\"]) &lt; 1:\n                print(f\"scan_list in {self.doc_conf_file} needs at least 1 file to scan, if file_list_scan is true\")\n                print()\n                print(\n                    \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            for element in self.doc_conf_data[\"scan_list\"]:\n                if not isinstance(element, str) or not element.endswith(\".gd\"):\n                    print(f\"Element {str(element)} in scan_list in {self.doc_conf_file} can't be scanned, only .gd \"\n                          f\"files are allowed\")\n                    print()\n                    print(\n                        \"For a full user documentation, visit \"\n                        \"https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                    )\n                    exit(5)\n                if not isfile(element):\n                    print(f\"Element {str(element)} in scan_list in {self.doc_conf_file} can't be scanned, file \"\n                          f\"doesn't exist\")\n                    print()\n                    print(\n                        \"For a full user documentation, visit \"\n                        \"https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                    )\n                    exit(2)\n\n    def collect_proj_files_info(self):\n        \"\"\"\n        Recursively gathering *.gd files from the project.\n\n        Additionally, reads project.godot file if read_gd_project is true, and gathers *.scene files recursively if\n        scene2src_links is true, to link them to the correspondant .gd script source files\n        \"\"\"\n        print(\"Scanning godot project ...\")\n        if self.doc_conf_data[\"project_scan_options\"][\"read_gd_project\"]:\n            gd_proj_file = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + \"/project.godot\"\n            if not isfile(gd_proj_file):\n                print(\n                    f\"Warning: File '{gd_proj_file}' not found, skipping project index\"\n                )\n            else:\n                try:\n                    with open(gd_proj_file, \"r\") as file:\n                        section = \"\"\n                        for line in file:\n                            line = line.strip()\n                            if line.startswith(\";\"):\n                                continue\n                            if line.startswith(\"[\") and line.endswith(\"]\"):\n                                section = line.strip(\"[\").strip(\"]\")\n                            if \"config/name=\" in line:\n                                project_name = line.replace(\"config/name=\", \"\").strip('\"')\n                                self.gd_project[\"project_name\"] = project_name\n                                continue\n                            if \"run/main_scene=\" in line:\n                                main_scene = line.replace(\"run/main_scene=\", \"\").strip('\"')\n                                main_scene = main_scene.replace(\"res://\", \"\")\n                                self.gd_project[\"main_scene\"][\"scene_path\"] = main_scene\n                                continue\n                            if \"config/features=PackedStringArray\" in line:\n                                godot_version = line.replace(\n                                    \"config/features=PackedStringArray\", \"\"\n                                ).strip(\"(\").strip(\")\")\n                                godot_version = godot_version.replace('\"', \"\")\n                                self.gd_project[\"godot_version\"] = godot_version\n                                continue\n                            if section == \"autoload\":\n                                if \"=\" in line:\n                                    line = line.split(\"=\", 1)\n                                    scene_name = line[0]\n                                    scene_path = line[1]\n                                    scene_path = scene_path.replace(\"res://\", \"\").strip('\"')\n                                    scene_autoload_enabled = True if scene_path.startswith(\"*\") else False\n                                    scene_path = scene_path.strip(\"*\")\n                                    self.gd_project[\"autoload\"].append({\n                                        \"scene_path\": scene_path,\n                                        \"scene_name\": scene_name,\n                                        \"enabled\": scene_autoload_enabled\n                                    })\n                except Exception as e:\n                    print(f\"Skipping project index, reading {gd_proj_file} failed with Exception:\")\n                    print(e)\n                    self.gd_project: dict = {\n                        \"project_name\": \"\",\n                        \"godot_version\": \"\",\n                        \"main_scene\": \"\"\n                    }\n                else:\n                    print(\"Godot project file analyzed\")\n        tmp_script_files = self.rec_find_files_with_ext(\n            \"gd\",\n            self.doc_conf_data[\"project_scan_options\"][\"src_path\"]\n        )\n        tmp_script_files = [\n            element.replace(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], \"\")\n            for element in tmp_script_files\n        ]\n        for file in tmp_script_files:\n            self.script_files[file] = {\n                \"scene\": \"\",\n                \"docs\": []\n            }\n        print(\"Project script files list created\")\n        if self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"]:\n            self.scene_files = self.rec_find_files_with_ext(\n                \"tscn\",\n                self.doc_conf_data[\"project_scan_options\"][\"src_path\"]\n            )\n            self.scene_files = [\n                element.replace(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], \"\")\n                for element in self.scene_files\n            ]\n            print(\"Project scene files list created\")\n\n    @staticmethod\n    def rec_find_files_with_ext(file_extension: str, search_directory: str) -&gt; list:\n        \"\"\"\n        Gathers a list of files with the given extension in the given directory\n\n        Args:\n            file_extension: The extension of the files to search for. Example: gd (and NOT *.gd)\n            search_directory: The directory from which to scan for the files recursively\n\n        Returns:\n            List with the full path of the files found with the given extension, relative to the working directory\n        \"\"\"\n        file_list: list = []\n        for root, dir_names, filenames in walk(search_directory):\n            for filename in filter(filenames, f\"*.{file_extension}\"):\n                file_list.append(join(root, filename))\n        return file_list\n\n    def connect_scene_to_script(self):\n        \"\"\"\n        Register scene connected to script where applicable\n        \"\"\"\n        for scene in self.scene_files:\n            fp_scene = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + scene\n            if isfile(fp_scene):\n                try:\n                    with open(fp_scene, \"r\") as file:\n                        for line in file:\n                            if 'ext_resource type=\"Script\"' not in line:\n                                continue\n                            script_path = line.strip(\"[\").strip(\"]\")\n                            script_path = script_path.replace(\n                                'ext_resource type=\"Script\" path=\"res://',\n                                \"\"\n                            )\n                            script_path = script_path.split('\"', 1)[0]\n                            self.script_files[script_path][\"scene\"] = scene\n                            break\n                except Exception as e:\n                    print(f\"Skipping file {fp_scene}, reading failed with exception:\")\n                    print(e)\n\n    def scan_project_scripts(self):\n        \"\"\"\n        Initiates scans of docstrings for all scripts in the project\n        \"\"\"\n        for script in self.script_files:\n            self.doc_data.append(self.script_scanner(script))\n\n    def scan_filelist_scripts(self):\n        \"\"\"\n        ToDo! Or not needed?\n        \"\"\"\n        pass\n\n    def script_scanner(self, script: str, from_project: bool = True) -&gt; ClassDoc:\n        \"\"\"\n        Scans docstrings from script, registering docstring class, signal, enum, enum values, const, var, func, and\n        inner class categories\n\n        Members of inner classes are not scanned at this time. Eventually becomes a feature in a future version.\n\n        Args:\n            script: Path to the script to read from\n            from_project: If True, the path of the script is relative to the project root (src_path)\n        \"\"\"\n        scan_stage: str = \"\"  # \"\", \"brief_description\", \"detail_description\", \"args\", \"returns\", todo: enum, func\n        tmp_brief_description = \"\"\n        tmp_detail_description = \"\"\n        tmp_args_description = []  # [name, type, description, value/default/required]\n        tmp_returns_description = []  # [type, description]\n        tmp_tags = []  # [tyg_type, (only if tag=@tutorial --&gt; url, not required tutorial_name]\n        class_doc = ClassDoc(script)\n        if from_project:\n            fp_script = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + script\n        else:\n            fp_script = script\n        try:\n            with (open(fp_script, \"r\") as file):\n                for line in file:\n                    if scan_stage == \"\":\n                        if line.strip().startswith(\"##\"):\n                            description_helper = line.replace(\"##\", \"\", 1).strip()\n                            if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                                scan_stage = \"brief_description\"\n                                if description_helper.startswith(\"@tutorial\"):\n                                    description_helper = description_helper.split(\":\", 1)\n                                    description_helper[1] = description_helper[1].strip()\n                                    if \"(\" in description_helper[0]:\n                                        if description_helper[0].endswith(\")\"):\n                                            tmp_list = description_helper[0].split(\"(\", 1)\n                                            if tmp_list[0] == \"@tutorial\":\n                                                description_helper[0] = \"@tutorial:\"\n                                                description_helper.append(tmp_list[1].strip(\")\"))\n                                            else:\n                                                print(f\"{line}: invalid @tutorial tag, skipping\")\n                                                continue\n                                        else:\n                                            print(f\"{line}: invalid @tutorial tag, skipping\")\n                                            continue\n                                    tag_to_append = [description_helper[0], description_helper[1]]\n                                    if len(description_helper) &gt; 2:\n                                        tag_to_append.append(description_helper[2])\n                                    if description_helper[0].endswith(\":\") and self.check_url(description_helper[1]):\n                                        tmp_tags.append(tag_to_append)\n                                    else:\n                                        print(f\"{line}: invalid @tutorial tag or URL, skipping\")\n                                        continue\n                                if description_helper.startswith(\"@deprecated\"):\n                                    tmp_tags.append(\"@deprecated\")\n                                if description_helper.startswith(\"@experimental\"):\n                                    tmp_tags.append(\"@experimental\")\n                                else:\n                                    tmp_brief_description = description_helper\n                            continue\n                        if line.strip().startswith(\"#\"):\n                            continue\n                        if line.strip().startswith(\"@export\"):\n                            scan_stage = \"@export\"\n                            continue\n                        if line.strip().startswith(\"@onready\"):\n                            scan_stage = \"@onready\"\n                            continue\n                        if \"##\" in line:\n                            if line.strip().startswith(\"signal\"):\n                                com, doc = line.split(\"##\", 1)\n                                signal_name = com.replace(\"signal\", \"\", 1).strip()\n                                signal_description = doc.strip()\n                                class_doc.add_signal(signal_name, signal_description)\n                                scan_stage = \"\"\n                                tmp_brief_description = \"\"\n                                tmp_detail_description = \"\"\n                                tmp_tags = []\n                                continue\n                            if line.strip().startswith(\"enum\"):\n                                scan_stage = \"enum\"\n                                com, doc = line.split(\"##\", 1)\n                                enum_name = \"\"\n                                enum_description = doc.strip()\n                                com = com.strip()\n                                if com.endswith(\"{\"):\n                                    com = com.replace(\"{\", \"\").strip()\n                                tmp_enum_members: list[enum_members] = []\n                                if com.endswith(\"}\"):\n                                    if \"{\" in com:\n                                        # todo: get enum members before enum_name and add to doc\n\n                                        continue\n                                    else:\n                                        # todo: enum parenthesis error\n\n                                        continue\n                                enum_name = com.replace(\"enum\", \"\", 1).strip()\n                                continue\n                            if line.strip().startswith(\"const\"):\n                                var_type = \"const\"\n                                const_value = None\n                                const_data_type = \"undefined\"\n                                com, doc = line.split(\"##\", 1)\n                                const_description = doc.strip()\n                                if \"=\" in com:\n                                    com, const_value = com.split(\"=\", 1)\n                                    const_value = const_value.strip()\n                                    com = com.strip()\n                                if \":=\" in com:\n                                    com, const_value = com.split(\"=\", 1)\n                                    const_value = const_value.strip()\n                                    com = com.strip()\n                                if \":\" in com:\n                                    com, const_data_type = com.split(\":\", 1)\n                                    const_data_type = const_data_type.strip()\n                                    com = com.strip()\n                                const_name = com.replace(\"const\", \"\", 1).strip\n                                class_doc.add_attribute(\n                                    const_name, const_data_type, const_description, const_value, const_data_type\n                                )\n                                scan_stage = \"\"\n                                tmp_brief_description = \"\"\n                                tmp_detail_description = \"\"\n                                tmp_tags = []\n                                continue\n                            if line.strip().startswith(\"@export var\") \\\n                                    or line.strip().startswith(\"var\") \\\n                                    or line.strip().startswith(\"@onready var\"):\n                                if line.strip().startswith(\"@export var\"):\n                                    var_type = \"@export var\"\n                                if line.strip().startswith(\"var\"):\n                                    var_type = \"var\"\n                                if line.strip().startswith(\"@onready var\"):\n                                    var_type = \"@onready var\"\n                                var_value = None\n                                var_data_type = \"undefined\"\n                                com, doc = line.split(\"##\", 1)\n                                var_description = doc.strip()\n                                if \"=\" in com:\n                                    com, var_value = com.split(\"=\", 1)\n                                    var_value = var_value.strip()\n                                    com = com.strip()\n                                if \":=\" in com:\n                                    com, var_value = com.split(\"=\", 1)\n                                    var_value = var_value.strip()\n                                    com = com.strip()\n                                if \":\" in com:\n                                    com, var_data_type = com.split(\":\", 1)\n                                    var_data_type = var_data_type.strip()\n                                    com = com.strip()\n                                var_name = com.replace(\"var\", 1).strip()\n                                var_name = var_name.replace(\"@onready\", 1).strip()\n                                var_name = var_name.replace(\"@export\", 1).strip()\n                                class_doc.add_attribute(var_name, var_data_type, var_description, var_value, var_type)\n                                continue\n                            if line.strip().startswith(\"func\"):\n\n                                continue\n                            if line.strip().startswith(\"class\"):\n\n                                continue\n                        if \"class_name\" in line:\n                            if line.startswith(\"class_name\"):\n                                class_name_helper = line.replace(\"class_name\", \"\").strip()\n                            else:\n                                class_name_helper = line.split(\"class_name\", 1)[1].strip()\n                            class_name_helper = class_name_helper.split(\" \", 1)[0]\n                            class_doc.set_class_name(class_name_helper)\n                        if \"extends\" in line:\n                            if line.startswith(\"extends\"):\n                                extends_helper = line.replace(\"extends\", \"\").strip()\n                            else:\n                                extends_helper = line.split(\"extends\", 1)[1].strip()\n                            extends_helper = extends_helper.split(\" \", 1)[0]\n                            class_doc.set_extends(extends_helper)\n                        continue\n                    if scan_stage == \"brief_description\":\n                        if line.strip().startswith(\"##\"):\n                            description_helper = line.replace(\"##\", \"\", 1).strip()\n                            if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                                tmp_brief_description += \" \" + description_helper\n                            else:\n                                scan_stage = \"detail_description\"\n                            continue\n                    if scan_stage == \"detail_description\":\n                        if line.strip().startswith(\"##\"):\n                            description_helper = line.replace(\"##\", \"\", 1)\n                            if description_helper.strip().startswith(\"Args:\"):\n                                scan_stage = \"args\"\n                                continue\n                            if description_helper.strip().startswith(\"Returns:\"):\n                                scan_stage = \"returns\"\n                                continue\n                            description_helper = description_helper.strip()\n                            if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                                if description_helper.startswith(\"@tutorial\"):\n                                    description_helper = description_helper.split(\":\", 1)\n                                    description_helper[1] = description_helper[1].strip()\n                                    if \"(\" in description_helper[0]:\n                                        if description_helper[0].endswith(\")\"):\n                                            tmp_list = description_helper[0].split(\"(\", 1)\n                                            if tmp_list[0] == \"@tutorial\":\n                                                description_helper[0] = \"@tutorial:\"\n                                                description_helper.append(tmp_list[1].strip(\")\"))\n                                            else:\n                                                print(f\"{line}: invalid @tutorial tag, skipping\")\n                                                continue\n                                        else:\n                                            print(f\"{line}: invalid @tutorial tag, skipping\")\n                                            continue\n                                    tag_to_append = [description_helper[0], description_helper[1]]\n                                    if len(description_helper) &gt; 2:\n                                        tag_to_append.append(description_helper[2])\n                                    if description_helper[0].endswith(\":\") and self.check_url(description_helper[1]):\n                                        tmp_tags.append(tag_to_append)\n                                        continue\n                                    else:\n                                        print(f\"{line}: invalid @tutorial tag, skipping\")\n                                        continue\n                                    pass\n                                if description_helper.startswith(\"@deprecated\"):\n                                    tmp_tags.append(\"@deprecated\")\n                                    continue\n                                if description_helper.startswith(\"@experimental\"):\n                                    tmp_tags.append(\"@experimental\")\n                                    continue\n                                else:\n                                    if tmp_detail_description != \"\":\n                                        description_helper = \" \" + description_helper\n                                    tmp_detail_description += description_helper\n                                    continue\n                            else:\n                                tmp_detail_description += \"\\n\\n\"\n                                continue\n                    if scan_stage == \"brief_description\" or scan_stage == \"detail_description\":\n                        if not line.strip().startswith(\"##\"):\n                            if line.strip().startswith(\"#\"):\n                                continue\n                            if line.strip().startswith(\"signal\"):\n                                if \"#\" in line:\n                                    line = line.split(\"#\", 1)[0]\n                                signal_name = line.replace(\"signal\", \"\", 1).strip()\n                                signal_description = tmp_brief_description\n                                if tmp_detail_description != \"\":\n                                    signal_description = signal_description + \"\\n\\n\" + tmp_detail_description\n                                signal_tags: list[TagDoc] = []\n                                for tag in tmp_tags:\n                                    tutorial_url = \"\"\n                                    tutorial_name = \"\"\n                                    tag_type = tag[0]\n                                    if len(tag) &gt; 1:\n                                        tutorial_url = tag[1]\n                                    if len(tag) &gt; 2:\n                                        tutorial_name = tag[2]\n                                    signal_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                                class_doc.add_signal(signal_name, signal_description, signal_tags)\n                                scan_stage = \"\"\n                                tmp_brief_description = \"\"\n                                tmp_detail_description = \"\"\n                                tmp_tags = []\n                                continue\n                            if line.strip().startswith(\"enum\"):\n                                scan_stage = \"enum\"\n                                enum_name = \"\"\n                                if \"#\" in line:\n                                    line = line.split(\"#\", 1)[0]\n                                line = line.strip()\n                                if line.endswith(\"{\"):\n                                    line = line.replace(\"{\", \"\").strip()\n                                enum_name = line.replace(\"enum\", \"\", 1).strip()\n                                enum_members: list[enum_members] = []\n                                continue\n                            if line.strip().startswith(\"const\"):\n                                var_type = \"const\"\n                                const_value = None\n                                const_data_type = \"undefined\"\n                                line = line.strip()\n                                if \"#\" in line:\n                                    line = line.split(\"#\", 1)[0].strip()\n                                if \"=\" in line:\n                                    line, const_value = line.split(\"=\", 1)\n                                    const_value = const_value.strip()\n                                    line = line.strip()\n                                if \":\" in line:\n                                    line, const_data_type = line.split(\":\", 1)\n                                    const_data_type = const_data_type.strip()\n                                    line = line.strip()\n                                const_name = line.replace(\"const\", \"\", 1).strip()\n                                const_description = tmp_brief_description\n                                if tmp_detail_description != \"\":\n                                    const_description = const_description + \"\\n\\n\" + tmp_brief_description\n                                const_tags: list[TagDoc] = []\n                                for tag in tmp_tags:\n                                    tutorial_url = \"\"\n                                    tutorial_name = \"\"\n                                    tag_type = tag[0]\n                                    if len(tag) &gt; 1:\n                                        tutorial_url = tag[1]\n                                    if len(tag) &gt; 2:\n                                        tutorial_name = tag[2]\n                                    const_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                                class_doc.add_attribute(\n                                    const_name, const_data_type, const_description, const_value, var_type, const_tags\n                                )\n                                scan_stage = \"\"\n                                tmp_brief_description = \"\"\n                                tmp_detail_description = \"\"\n                                tmp_tags = []\n                                continue\n                            if line.strip().startswith(\"@export var\") \\\n                                    or line.strip().startswith(\"var\") \\\n                                    or line.strip().startswith(\"@onready var\"):\n                                if \"#\" in line:\n                                    line = line.split(\"#\", 1)[0].strip()\n                                if line.strip().startswith(\"@export var\"):\n                                    var_type = \"@export var\"\n                                if line.strip().startswith(\"var\"):\n                                    var_type = \"var\"\n                                if line.strip().startswith(\"@onready var\"):\n                                    var_type = \"@onready var\"\n                                var_value = None\n                                var_data_type = \"undefined\"\n                                if \"=\" in line:\n                                    line, var_value = line.split(\"=\", 1)\n                                    var_value = var_value.strip()\n                                    line = line.strip()\n                                elif \":=\" in line:\n                                    line, var_value = line.split(\":=\", 1)\n                                    var_value = var_value.strip()\n                                    line = line.strip()\n                                if \":\" in line:\n                                    line, var_data_type = line.split(\":\", 1)\n                                    var_data_type = var_data_type.strip()\n                                    line = line.strip()\n                                var_name = line.replace(\"var\", \"\", 1).strip()\n                                var_name = var_name.replace(\"@onready\", \"\", 1).strip()\n                                var_name = var_name.replace(\"@export\", \"\", 1).strip()\n                                var_description = tmp_brief_description\n                                if tmp_detail_description != \"\":\n                                    var_description = var_description + \"\\n\\n\" + tmp_detail_description\n                                var_tags: list[TagDoc] = []\n                                for tag in tmp_tags:\n                                    tutorial_url = \"\"\n                                    tutorial_name = \"\"\n                                    tag_type = tag[0]\n                                    if len(tag) &gt; 1:\n                                        tutorial_url = tag[1]\n                                    if len(tag) &gt; 2:\n                                        tutorial_name = tag[2]\n                                    var_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                                class_doc.add_attribute(\n                                    var_name, var_data_type, var_description, var_value, var_type, var_tags\n                                )\n                                scan_stage = \"\"\n                                tmp_brief_description = \"\"\n                                tmp_detail_description = \"\"\n                                tmp_tags = []\n                                continue\n                            if line.strip().startswith(\"@export\"):\n                                scan_stage = \"@export\"\n                                continue\n                            if line.strip().startswith(\"@onready\"):\n                                scan_stage = \"@onready\"\n                                continue\n                            if line.strip().startswith(\"func\"):\n\n                                continue\n                            if line.strip().startswith(\"class\"):\n\n                                continue\n                            # todo: should be class docstring if nothing of the above\n                    if scan_stage == \"@export\" or scan_stage == \"@onready\":\n                        if scan_stage == \"@export\":\n                            if not line.strip().startswith(\"var\"):\n                                print(\"Warning: @export is not followed by var, ignoring ...\")\n                                continue\n                            else:\n                                var_type = \"@export var\"\n                        if scan_stage == \"@onready\":\n                            if not line.strip().startswith(\"var\"):\n                                print(\"Warning: @onready is not followed by var, ignoring ...\")\n                                continue\n                            else:\n                                var_type = \"@onready var\"\n                        var_value = None\n                        var_data_type = \"undefined\"\n                        if \"=\" in line:\n                            line, var_value = line.split(\"=\", 1)\n                            var_value = var_value.strip()\n                            line = line.strip()\n                        if \":=\" in line:\n                            line, var_value = line.split(\":=\", 1)\n                            var_value = var_value.strip()\n                            line = line.strip()\n                        if \":\" in line:\n                            line, var_data_type = line.split(\":\", 1)\n                            var_data_type = var_data_type.strip()\n                            line = line.strip()\n                        var_name = line.replace(\"var\", \"\", 1).strip()\n                        var_name = var_name.replace(\"@onready\", \"\", 1).strip()\n                        var_name = var_name.replace(\"@export\", \"\", 1).strip()\n                        var_description = tmp_brief_description\n                        if tmp_detail_description != \"\":\n                            var_description = var_description + \"\\n\\n\" + tmp_detail_description\n                        var_tags: list[TagDoc] = []\n                        for tag in tmp_tags:\n                            tutorial_url = \"\"\n                            tutorial_name = \"\"\n                            tag_type = tag[0]\n                            if len(tag) &gt; 1:\n                                tutorial_url = tag[1]\n                            if len(tag) &gt; 2:\n                                tutorial_name = tag[2]\n                            var_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                        class_doc.add_attribute(\n                            var_name, var_data_type, var_description, var_value, var_type, var_tags\n                        )\n                        scan_stage = \"\"\n                        tmp_brief_description = \"\"\n                        tmp_detail_description = \"\"\n                        tmp_tags = []\n                        continue\n                    if scan_stage == \"enum\":\n                        line = line.strip()\n                        if \"#\" in line and \"##\" not in line:\n                            line = line.split(\"#\", 1)[0].strip()\n                        if line == \"{\" or line == \"\":\n                            continue\n                        if line.startswith(\"##\"):\n                            line = line.replace(\"##\", \"\").strip()\n                            if \"enum_member_tmp_description\" in locals():\n                                if enum_member_description != \"\" or enum_member_description is not None:\n                                    enum_member_description = enum_member_description + \" \" + line\n                                else:\n                                    enum_member_description = line\n                            else:\n                                enum_member_description = line\n                            continue\n                        if \"##\" in line:\n                            com, doc = line.split(\"##\")\n                            com = com.strip()\n                            doc = doc.strip\n                            if \"enum_member_tmp_description\" in locals():\n                                if enum_member_description != \"\" or enum_member_description is not None:\n                                    enum_member_description = enum_member_description + \" \" + doc\n                                else:\n                                    enum_member_description = doc\n                            else:\n                                enum_member_description = doc\n                            if \"=\" in line:\n                                enum_member_value_name, enum_member_value_int = line.split(\"=\")\n                                enum_member_value_name = enum_member_value_name.strip()\n                                enum_member_value_int = enum_member_value_int.strip()\n                            else:\n                                enum_member_value_name = line.strip()\n                                if len(tmp_enum_members) &lt; 1:\n                                    enum_member_value_int = 0\n                                else:\n                                    enum_member_value_int = tmp_enum_members[-1].value_int + 1\n                            tmp_enum_members.append(\n                                EnumMemberDoc(enum_member_value_name, enum_member_value_int, enum_member_description)\n                            )\n                            continue\n                        if \"=\" in line:\n                            enum_member_value_name, enum_member_value_int = line.split(\"=\")\n                            enum_member_value_name = enum_member_value_name.strip()\n                            enum_member_value_int = enum_member_value_int.strip()\n                        else:\n                            enum_member_value_name = line.strip()\n                            if len(tmp_enum_members) &lt; 1:\n                                enum_member_value_int = 0\n                            else:\n                                enum_member_value_int = tmp_enum_members[-1].value_int + 1\n                        tmp_enum_members.append(\n                            EnumMemberDoc(enum_member_value_name, enum_member_value_int, enum_member_description)\n                        )\n                        if line.endswith(\"}\"):\n                            # todo: add enum with members to doc\n\n                            pass\n                        continue\n                    if scan_stage == \"args\":\n\n                        continue\n                    if scan_stage == \"returns\":\n\n                        continue\n        except Exception as e:\n\n            # todo: broader exception handling\n            print(e)\n        return class_doc\n\n    @staticmethod\n    def check_url(url_to_check: str) -&gt; bool:\n        \"\"\"\n        Checks the pattern of an HTTP(S) URL address. Doesn't check if address exists.\n\n        Args:\n            url_to_check: URL address to check\n\n        Returns:\n            True if HTTP(S) URL address pattern is valid, otherwise False\n        \"\"\"\n        if url(url_to_check):\n            if url_to_check.startswith(\"http://\") or url_to_check.startswith(\"https://\"):\n                return True\n        return False\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.__init__","title":"<code>__init__(doc_conf_data, doc_conf_file)</code>","text":"<p>Constructor of the class. Anything from reading project to building documentation sites is done from here.</p> <p>Parameters:</p> Name Type Description Default <code>doc_conf_data</code> <code>CommentedMap</code> <p>The deserialized settings for reading the sourcecode</p> required <code>doc_conf_file</code> <code>str</code> <p>Path to the documentation config file</p> required Source code in <code>src/control/build.py</code> <pre><code>def __init__(self, doc_conf_data: CommentedMap, doc_conf_file: str):\n    \"\"\"\n    Constructor of the class. Anything from reading project to building documentation sites is done from here.\n\n    Args:\n        doc_conf_data: The deserialized settings for reading the sourcecode\n        doc_conf_file: Path to the documentation config file\n    \"\"\"\n    self.doc_conf_data: CommentedMap = doc_conf_data\n    self.doc_conf_file: str = doc_conf_file\n    self.gd_project: dict = {\n        \"project_name\": \"\",\n        \"godot_version\": \"\",\n        \"main_scene\": {\n            \"scene_path\": \"\",\n            \"added_script\": \"\"\n        },\n        \"autoload\": []\n    }\n    self.doc_data: list[ClassDoc] = []\n    self.script_files: dict = {}\n    self.scene_files: list = []\n    self.check_doc_conf_data()\n    print(f\"Check of {self.doc_conf_file} configuration file finished, everything seems ok\")\n    if self.doc_conf_data[\"project_scan\"]:\n        self.collect_proj_files_info()\n        if self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"]:\n            self.connect_scene_to_script()\n        self.scan_project_scripts()\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.check_doc_conf_data","title":"<code>check_doc_conf_data()</code>","text":"<p>Checks if the configuration data are correct. Exits directly after printing error message if not.</p> Source code in <code>src/control/build.py</code> <pre><code>def check_doc_conf_data(self):\n    \"\"\"\n    Checks if the configuration data are correct. Exits directly after printing error message if not.\n    \"\"\"\n    # todo: point to according chapter/subsite in error msgs urls?\n    print(\"Checking settings correctness before reading &amp; building ...\")\n    # print(self.doc_conf_data)\n    if \"doc_destination\" not in self.doc_conf_data or self.doc_conf_data[\"doc_destination\"] == \"\" \\\n            or not isinstance(self.doc_conf_data[\"doc_destination\"], str):\n        print(f\"doc_destination not set in {self.doc_conf_file}, empty or wrong type\")\n        print()\n        print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n        exit(5)\n    if \"rebuild_src_path\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"rebuild_src_path\"], bool):\n        print(f\"rebuild_src_path not set in {self.doc_conf_file} or wrong type\")\n        exit(5)\n    if \"project_scan\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"rebuild_src_path\"], bool):\n        print(f\"project_scan not set in {self.doc_conf_file} or wrong type\")\n        print()\n        print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n        exit(5)\n    if self.doc_conf_data[\"project_scan\"]:\n        if \"project_scan_options\" not in self.doc_conf_data \\\n                or not isinstance(self.doc_conf_data[\"project_scan_options\"], CommentedMap):\n            print(f\"project_scan_options not set in {self.doc_conf_file}, wrong type or empty\")\n            print(\"project_scan_options are needed if project_scan is true\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        if \"src_path\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                or self.doc_conf_data[\"project_scan_options\"][\"src_path\"] == \"\"\\\n                or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], str):\n            print(f\"src_path wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n            exit(5)\n        if self.doc_conf_data[\"project_scan_options\"][\"src_path\"] == self.doc_conf_data[\"doc_destination\"]:\n            print(f\"Conflicting options: src_path in project_scan_options can't be the same as doc_destination in \"\n                  f\"{self.doc_conf_file} settings file\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        if \"read_gd_project\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"read_gd_project\"], bool):\n            print(f\"read_gd_project wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        if \"scene2src_links\" not in self.doc_conf_data[\"project_scan_options\"] \\\n                or not isinstance(self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"], bool):\n            print(f\"scene2src_links wrong type or not set in project_scan_option in {self.doc_conf_file}\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        if not isdir(self.doc_conf_data[\"project_scan_options\"][\"src_path\"]):\n            print(f\"src_path in project_scan_options in {self.doc_conf_file} doesn't exist\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(2)\n    if \"filelist_scan\" not in self.doc_conf_data or not isinstance(self.doc_conf_data[\"filelist_scan\"], bool):\n        print(f\"filelist_scan not set in {self.doc_conf_file} or wrong type\")\n        print()\n        print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n        exit(5)\n    if not self.doc_conf_data[\"project_scan\"] and not self.doc_conf_data[\"filelist_scan\"]:\n        print(f\"At least one of the options project_scan or filelist_scan needs to be set true, otherwise theres \"\n              f\"nothing to scan\")\n        print()\n        print(\"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\")\n        exit(5)\n    if self.doc_conf_data[\"filelist_scan\"]:\n        if \"scan_list\" not in self.doc_conf_data \\\n                or not isinstance(self.doc_conf_data[\"scan_list\"], CommentedSeq):\n            print(f\"scan_list not set in {self.doc_conf_file}, wrong type or empty\")\n            print(\"scan_list is needed if filelist_scan is true\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        if len(self.doc_conf_data[\"scan_list\"]) &lt; 1:\n            print(f\"scan_list in {self.doc_conf_file} needs at least 1 file to scan, if file_list_scan is true\")\n            print()\n            print(\n                \"For a full user documentation, visit https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n            )\n            exit(5)\n        for element in self.doc_conf_data[\"scan_list\"]:\n            if not isinstance(element, str) or not element.endswith(\".gd\"):\n                print(f\"Element {str(element)} in scan_list in {self.doc_conf_file} can't be scanned, only .gd \"\n                      f\"files are allowed\")\n                print()\n                print(\n                    \"For a full user documentation, visit \"\n                    \"https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(5)\n            if not isfile(element):\n                print(f\"Element {str(element)} in scan_list in {self.doc_conf_file} can't be scanned, file \"\n                      f\"doesn't exist\")\n                print()\n                print(\n                    \"For a full user documentation, visit \"\n                    \"https://sbo-games-development.github.io/md_gd4_docs/userdoc/\"\n                )\n                exit(2)\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.check_url","title":"<code>check_url(url_to_check)</code>  <code>staticmethod</code>","text":"<p>Checks the pattern of an HTTP(S) URL address. Doesn't check if address exists.</p> <p>Parameters:</p> Name Type Description Default <code>url_to_check</code> <code>str</code> <p>URL address to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if HTTP(S) URL address pattern is valid, otherwise False</p> Source code in <code>src/control/build.py</code> <pre><code>@staticmethod\ndef check_url(url_to_check: str) -&gt; bool:\n    \"\"\"\n    Checks the pattern of an HTTP(S) URL address. Doesn't check if address exists.\n\n    Args:\n        url_to_check: URL address to check\n\n    Returns:\n        True if HTTP(S) URL address pattern is valid, otherwise False\n    \"\"\"\n    if url(url_to_check):\n        if url_to_check.startswith(\"http://\") or url_to_check.startswith(\"https://\"):\n            return True\n    return False\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.collect_proj_files_info","title":"<code>collect_proj_files_info()</code>","text":"<p>Recursively gathering *.gd files from the project.</p> <p>Additionally, reads project.godot file if read_gd_project is true, and gathers *.scene files recursively if scene2src_links is true, to link them to the correspondant .gd script source files</p> Source code in <code>src/control/build.py</code> <pre><code>def collect_proj_files_info(self):\n    \"\"\"\n    Recursively gathering *.gd files from the project.\n\n    Additionally, reads project.godot file if read_gd_project is true, and gathers *.scene files recursively if\n    scene2src_links is true, to link them to the correspondant .gd script source files\n    \"\"\"\n    print(\"Scanning godot project ...\")\n    if self.doc_conf_data[\"project_scan_options\"][\"read_gd_project\"]:\n        gd_proj_file = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + \"/project.godot\"\n        if not isfile(gd_proj_file):\n            print(\n                f\"Warning: File '{gd_proj_file}' not found, skipping project index\"\n            )\n        else:\n            try:\n                with open(gd_proj_file, \"r\") as file:\n                    section = \"\"\n                    for line in file:\n                        line = line.strip()\n                        if line.startswith(\";\"):\n                            continue\n                        if line.startswith(\"[\") and line.endswith(\"]\"):\n                            section = line.strip(\"[\").strip(\"]\")\n                        if \"config/name=\" in line:\n                            project_name = line.replace(\"config/name=\", \"\").strip('\"')\n                            self.gd_project[\"project_name\"] = project_name\n                            continue\n                        if \"run/main_scene=\" in line:\n                            main_scene = line.replace(\"run/main_scene=\", \"\").strip('\"')\n                            main_scene = main_scene.replace(\"res://\", \"\")\n                            self.gd_project[\"main_scene\"][\"scene_path\"] = main_scene\n                            continue\n                        if \"config/features=PackedStringArray\" in line:\n                            godot_version = line.replace(\n                                \"config/features=PackedStringArray\", \"\"\n                            ).strip(\"(\").strip(\")\")\n                            godot_version = godot_version.replace('\"', \"\")\n                            self.gd_project[\"godot_version\"] = godot_version\n                            continue\n                        if section == \"autoload\":\n                            if \"=\" in line:\n                                line = line.split(\"=\", 1)\n                                scene_name = line[0]\n                                scene_path = line[1]\n                                scene_path = scene_path.replace(\"res://\", \"\").strip('\"')\n                                scene_autoload_enabled = True if scene_path.startswith(\"*\") else False\n                                scene_path = scene_path.strip(\"*\")\n                                self.gd_project[\"autoload\"].append({\n                                    \"scene_path\": scene_path,\n                                    \"scene_name\": scene_name,\n                                    \"enabled\": scene_autoload_enabled\n                                })\n            except Exception as e:\n                print(f\"Skipping project index, reading {gd_proj_file} failed with Exception:\")\n                print(e)\n                self.gd_project: dict = {\n                    \"project_name\": \"\",\n                    \"godot_version\": \"\",\n                    \"main_scene\": \"\"\n                }\n            else:\n                print(\"Godot project file analyzed\")\n    tmp_script_files = self.rec_find_files_with_ext(\n        \"gd\",\n        self.doc_conf_data[\"project_scan_options\"][\"src_path\"]\n    )\n    tmp_script_files = [\n        element.replace(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], \"\")\n        for element in tmp_script_files\n    ]\n    for file in tmp_script_files:\n        self.script_files[file] = {\n            \"scene\": \"\",\n            \"docs\": []\n        }\n    print(\"Project script files list created\")\n    if self.doc_conf_data[\"project_scan_options\"][\"scene2src_links\"]:\n        self.scene_files = self.rec_find_files_with_ext(\n            \"tscn\",\n            self.doc_conf_data[\"project_scan_options\"][\"src_path\"]\n        )\n        self.scene_files = [\n            element.replace(self.doc_conf_data[\"project_scan_options\"][\"src_path\"], \"\")\n            for element in self.scene_files\n        ]\n        print(\"Project scene files list created\")\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.connect_scene_to_script","title":"<code>connect_scene_to_script()</code>","text":"<p>Register scene connected to script where applicable</p> Source code in <code>src/control/build.py</code> <pre><code>def connect_scene_to_script(self):\n    \"\"\"\n    Register scene connected to script where applicable\n    \"\"\"\n    for scene in self.scene_files:\n        fp_scene = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + scene\n        if isfile(fp_scene):\n            try:\n                with open(fp_scene, \"r\") as file:\n                    for line in file:\n                        if 'ext_resource type=\"Script\"' not in line:\n                            continue\n                        script_path = line.strip(\"[\").strip(\"]\")\n                        script_path = script_path.replace(\n                            'ext_resource type=\"Script\" path=\"res://',\n                            \"\"\n                        )\n                        script_path = script_path.split('\"', 1)[0]\n                        self.script_files[script_path][\"scene\"] = scene\n                        break\n            except Exception as e:\n                print(f\"Skipping file {fp_scene}, reading failed with exception:\")\n                print(e)\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.rec_find_files_with_ext","title":"<code>rec_find_files_with_ext(file_extension, search_directory)</code>  <code>staticmethod</code>","text":"<p>Gathers a list of files with the given extension in the given directory</p> <p>Parameters:</p> Name Type Description Default <code>file_extension</code> <code>str</code> <p>The extension of the files to search for. Example: gd (and NOT *.gd)</p> required <code>search_directory</code> <code>str</code> <p>The directory from which to scan for the files recursively</p> required <p>Returns:</p> Type Description <code>list</code> <p>List with the full path of the files found with the given extension, relative to the working directory</p> Source code in <code>src/control/build.py</code> <pre><code>@staticmethod\ndef rec_find_files_with_ext(file_extension: str, search_directory: str) -&gt; list:\n    \"\"\"\n    Gathers a list of files with the given extension in the given directory\n\n    Args:\n        file_extension: The extension of the files to search for. Example: gd (and NOT *.gd)\n        search_directory: The directory from which to scan for the files recursively\n\n    Returns:\n        List with the full path of the files found with the given extension, relative to the working directory\n    \"\"\"\n    file_list: list = []\n    for root, dir_names, filenames in walk(search_directory):\n        for filename in filter(filenames, f\"*.{file_extension}\"):\n            file_list.append(join(root, filename))\n    return file_list\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.scan_filelist_scripts","title":"<code>scan_filelist_scripts()</code>","text":"<p>ToDo! Or not needed?</p> Source code in <code>src/control/build.py</code> <pre><code>def scan_filelist_scripts(self):\n    \"\"\"\n    ToDo! Or not needed?\n    \"\"\"\n    pass\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.scan_project_scripts","title":"<code>scan_project_scripts()</code>","text":"<p>Initiates scans of docstrings for all scripts in the project</p> Source code in <code>src/control/build.py</code> <pre><code>def scan_project_scripts(self):\n    \"\"\"\n    Initiates scans of docstrings for all scripts in the project\n    \"\"\"\n    for script in self.script_files:\n        self.doc_data.append(self.script_scanner(script))\n</code></pre>"},{"location":"src/control/build/#src.control.build.Build.script_scanner","title":"<code>script_scanner(script, from_project=True)</code>","text":"<p>Scans docstrings from script, registering docstring class, signal, enum, enum values, const, var, func, and inner class categories</p> <p>Members of inner classes are not scanned at this time. Eventually becomes a feature in a future version.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>str</code> <p>Path to the script to read from</p> required <code>from_project</code> <code>bool</code> <p>If True, the path of the script is relative to the project root (src_path)</p> <code>True</code> Source code in <code>src/control/build.py</code> <pre><code>def script_scanner(self, script: str, from_project: bool = True) -&gt; ClassDoc:\n    \"\"\"\n    Scans docstrings from script, registering docstring class, signal, enum, enum values, const, var, func, and\n    inner class categories\n\n    Members of inner classes are not scanned at this time. Eventually becomes a feature in a future version.\n\n    Args:\n        script: Path to the script to read from\n        from_project: If True, the path of the script is relative to the project root (src_path)\n    \"\"\"\n    scan_stage: str = \"\"  # \"\", \"brief_description\", \"detail_description\", \"args\", \"returns\", todo: enum, func\n    tmp_brief_description = \"\"\n    tmp_detail_description = \"\"\n    tmp_args_description = []  # [name, type, description, value/default/required]\n    tmp_returns_description = []  # [type, description]\n    tmp_tags = []  # [tyg_type, (only if tag=@tutorial --&gt; url, not required tutorial_name]\n    class_doc = ClassDoc(script)\n    if from_project:\n        fp_script = self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + script\n    else:\n        fp_script = script\n    try:\n        with (open(fp_script, \"r\") as file):\n            for line in file:\n                if scan_stage == \"\":\n                    if line.strip().startswith(\"##\"):\n                        description_helper = line.replace(\"##\", \"\", 1).strip()\n                        if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                            scan_stage = \"brief_description\"\n                            if description_helper.startswith(\"@tutorial\"):\n                                description_helper = description_helper.split(\":\", 1)\n                                description_helper[1] = description_helper[1].strip()\n                                if \"(\" in description_helper[0]:\n                                    if description_helper[0].endswith(\")\"):\n                                        tmp_list = description_helper[0].split(\"(\", 1)\n                                        if tmp_list[0] == \"@tutorial\":\n                                            description_helper[0] = \"@tutorial:\"\n                                            description_helper.append(tmp_list[1].strip(\")\"))\n                                        else:\n                                            print(f\"{line}: invalid @tutorial tag, skipping\")\n                                            continue\n                                    else:\n                                        print(f\"{line}: invalid @tutorial tag, skipping\")\n                                        continue\n                                tag_to_append = [description_helper[0], description_helper[1]]\n                                if len(description_helper) &gt; 2:\n                                    tag_to_append.append(description_helper[2])\n                                if description_helper[0].endswith(\":\") and self.check_url(description_helper[1]):\n                                    tmp_tags.append(tag_to_append)\n                                else:\n                                    print(f\"{line}: invalid @tutorial tag or URL, skipping\")\n                                    continue\n                            if description_helper.startswith(\"@deprecated\"):\n                                tmp_tags.append(\"@deprecated\")\n                            if description_helper.startswith(\"@experimental\"):\n                                tmp_tags.append(\"@experimental\")\n                            else:\n                                tmp_brief_description = description_helper\n                        continue\n                    if line.strip().startswith(\"#\"):\n                        continue\n                    if line.strip().startswith(\"@export\"):\n                        scan_stage = \"@export\"\n                        continue\n                    if line.strip().startswith(\"@onready\"):\n                        scan_stage = \"@onready\"\n                        continue\n                    if \"##\" in line:\n                        if line.strip().startswith(\"signal\"):\n                            com, doc = line.split(\"##\", 1)\n                            signal_name = com.replace(\"signal\", \"\", 1).strip()\n                            signal_description = doc.strip()\n                            class_doc.add_signal(signal_name, signal_description)\n                            scan_stage = \"\"\n                            tmp_brief_description = \"\"\n                            tmp_detail_description = \"\"\n                            tmp_tags = []\n                            continue\n                        if line.strip().startswith(\"enum\"):\n                            scan_stage = \"enum\"\n                            com, doc = line.split(\"##\", 1)\n                            enum_name = \"\"\n                            enum_description = doc.strip()\n                            com = com.strip()\n                            if com.endswith(\"{\"):\n                                com = com.replace(\"{\", \"\").strip()\n                            tmp_enum_members: list[enum_members] = []\n                            if com.endswith(\"}\"):\n                                if \"{\" in com:\n                                    # todo: get enum members before enum_name and add to doc\n\n                                    continue\n                                else:\n                                    # todo: enum parenthesis error\n\n                                    continue\n                            enum_name = com.replace(\"enum\", \"\", 1).strip()\n                            continue\n                        if line.strip().startswith(\"const\"):\n                            var_type = \"const\"\n                            const_value = None\n                            const_data_type = \"undefined\"\n                            com, doc = line.split(\"##\", 1)\n                            const_description = doc.strip()\n                            if \"=\" in com:\n                                com, const_value = com.split(\"=\", 1)\n                                const_value = const_value.strip()\n                                com = com.strip()\n                            if \":=\" in com:\n                                com, const_value = com.split(\"=\", 1)\n                                const_value = const_value.strip()\n                                com = com.strip()\n                            if \":\" in com:\n                                com, const_data_type = com.split(\":\", 1)\n                                const_data_type = const_data_type.strip()\n                                com = com.strip()\n                            const_name = com.replace(\"const\", \"\", 1).strip\n                            class_doc.add_attribute(\n                                const_name, const_data_type, const_description, const_value, const_data_type\n                            )\n                            scan_stage = \"\"\n                            tmp_brief_description = \"\"\n                            tmp_detail_description = \"\"\n                            tmp_tags = []\n                            continue\n                        if line.strip().startswith(\"@export var\") \\\n                                or line.strip().startswith(\"var\") \\\n                                or line.strip().startswith(\"@onready var\"):\n                            if line.strip().startswith(\"@export var\"):\n                                var_type = \"@export var\"\n                            if line.strip().startswith(\"var\"):\n                                var_type = \"var\"\n                            if line.strip().startswith(\"@onready var\"):\n                                var_type = \"@onready var\"\n                            var_value = None\n                            var_data_type = \"undefined\"\n                            com, doc = line.split(\"##\", 1)\n                            var_description = doc.strip()\n                            if \"=\" in com:\n                                com, var_value = com.split(\"=\", 1)\n                                var_value = var_value.strip()\n                                com = com.strip()\n                            if \":=\" in com:\n                                com, var_value = com.split(\"=\", 1)\n                                var_value = var_value.strip()\n                                com = com.strip()\n                            if \":\" in com:\n                                com, var_data_type = com.split(\":\", 1)\n                                var_data_type = var_data_type.strip()\n                                com = com.strip()\n                            var_name = com.replace(\"var\", 1).strip()\n                            var_name = var_name.replace(\"@onready\", 1).strip()\n                            var_name = var_name.replace(\"@export\", 1).strip()\n                            class_doc.add_attribute(var_name, var_data_type, var_description, var_value, var_type)\n                            continue\n                        if line.strip().startswith(\"func\"):\n\n                            continue\n                        if line.strip().startswith(\"class\"):\n\n                            continue\n                    if \"class_name\" in line:\n                        if line.startswith(\"class_name\"):\n                            class_name_helper = line.replace(\"class_name\", \"\").strip()\n                        else:\n                            class_name_helper = line.split(\"class_name\", 1)[1].strip()\n                        class_name_helper = class_name_helper.split(\" \", 1)[0]\n                        class_doc.set_class_name(class_name_helper)\n                    if \"extends\" in line:\n                        if line.startswith(\"extends\"):\n                            extends_helper = line.replace(\"extends\", \"\").strip()\n                        else:\n                            extends_helper = line.split(\"extends\", 1)[1].strip()\n                        extends_helper = extends_helper.split(\" \", 1)[0]\n                        class_doc.set_extends(extends_helper)\n                    continue\n                if scan_stage == \"brief_description\":\n                    if line.strip().startswith(\"##\"):\n                        description_helper = line.replace(\"##\", \"\", 1).strip()\n                        if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                            tmp_brief_description += \" \" + description_helper\n                        else:\n                            scan_stage = \"detail_description\"\n                        continue\n                if scan_stage == \"detail_description\":\n                    if line.strip().startswith(\"##\"):\n                        description_helper = line.replace(\"##\", \"\", 1)\n                        if description_helper.strip().startswith(\"Args:\"):\n                            scan_stage = \"args\"\n                            continue\n                        if description_helper.strip().startswith(\"Returns:\"):\n                            scan_stage = \"returns\"\n                            continue\n                        description_helper = description_helper.strip()\n                        if not description_helper.replace(\"#\", \"\").strip() == \"\":\n                            if description_helper.startswith(\"@tutorial\"):\n                                description_helper = description_helper.split(\":\", 1)\n                                description_helper[1] = description_helper[1].strip()\n                                if \"(\" in description_helper[0]:\n                                    if description_helper[0].endswith(\")\"):\n                                        tmp_list = description_helper[0].split(\"(\", 1)\n                                        if tmp_list[0] == \"@tutorial\":\n                                            description_helper[0] = \"@tutorial:\"\n                                            description_helper.append(tmp_list[1].strip(\")\"))\n                                        else:\n                                            print(f\"{line}: invalid @tutorial tag, skipping\")\n                                            continue\n                                    else:\n                                        print(f\"{line}: invalid @tutorial tag, skipping\")\n                                        continue\n                                tag_to_append = [description_helper[0], description_helper[1]]\n                                if len(description_helper) &gt; 2:\n                                    tag_to_append.append(description_helper[2])\n                                if description_helper[0].endswith(\":\") and self.check_url(description_helper[1]):\n                                    tmp_tags.append(tag_to_append)\n                                    continue\n                                else:\n                                    print(f\"{line}: invalid @tutorial tag, skipping\")\n                                    continue\n                                pass\n                            if description_helper.startswith(\"@deprecated\"):\n                                tmp_tags.append(\"@deprecated\")\n                                continue\n                            if description_helper.startswith(\"@experimental\"):\n                                tmp_tags.append(\"@experimental\")\n                                continue\n                            else:\n                                if tmp_detail_description != \"\":\n                                    description_helper = \" \" + description_helper\n                                tmp_detail_description += description_helper\n                                continue\n                        else:\n                            tmp_detail_description += \"\\n\\n\"\n                            continue\n                if scan_stage == \"brief_description\" or scan_stage == \"detail_description\":\n                    if not line.strip().startswith(\"##\"):\n                        if line.strip().startswith(\"#\"):\n                            continue\n                        if line.strip().startswith(\"signal\"):\n                            if \"#\" in line:\n                                line = line.split(\"#\", 1)[0]\n                            signal_name = line.replace(\"signal\", \"\", 1).strip()\n                            signal_description = tmp_brief_description\n                            if tmp_detail_description != \"\":\n                                signal_description = signal_description + \"\\n\\n\" + tmp_detail_description\n                            signal_tags: list[TagDoc] = []\n                            for tag in tmp_tags:\n                                tutorial_url = \"\"\n                                tutorial_name = \"\"\n                                tag_type = tag[0]\n                                if len(tag) &gt; 1:\n                                    tutorial_url = tag[1]\n                                if len(tag) &gt; 2:\n                                    tutorial_name = tag[2]\n                                signal_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                            class_doc.add_signal(signal_name, signal_description, signal_tags)\n                            scan_stage = \"\"\n                            tmp_brief_description = \"\"\n                            tmp_detail_description = \"\"\n                            tmp_tags = []\n                            continue\n                        if line.strip().startswith(\"enum\"):\n                            scan_stage = \"enum\"\n                            enum_name = \"\"\n                            if \"#\" in line:\n                                line = line.split(\"#\", 1)[0]\n                            line = line.strip()\n                            if line.endswith(\"{\"):\n                                line = line.replace(\"{\", \"\").strip()\n                            enum_name = line.replace(\"enum\", \"\", 1).strip()\n                            enum_members: list[enum_members] = []\n                            continue\n                        if line.strip().startswith(\"const\"):\n                            var_type = \"const\"\n                            const_value = None\n                            const_data_type = \"undefined\"\n                            line = line.strip()\n                            if \"#\" in line:\n                                line = line.split(\"#\", 1)[0].strip()\n                            if \"=\" in line:\n                                line, const_value = line.split(\"=\", 1)\n                                const_value = const_value.strip()\n                                line = line.strip()\n                            if \":\" in line:\n                                line, const_data_type = line.split(\":\", 1)\n                                const_data_type = const_data_type.strip()\n                                line = line.strip()\n                            const_name = line.replace(\"const\", \"\", 1).strip()\n                            const_description = tmp_brief_description\n                            if tmp_detail_description != \"\":\n                                const_description = const_description + \"\\n\\n\" + tmp_brief_description\n                            const_tags: list[TagDoc] = []\n                            for tag in tmp_tags:\n                                tutorial_url = \"\"\n                                tutorial_name = \"\"\n                                tag_type = tag[0]\n                                if len(tag) &gt; 1:\n                                    tutorial_url = tag[1]\n                                if len(tag) &gt; 2:\n                                    tutorial_name = tag[2]\n                                const_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                            class_doc.add_attribute(\n                                const_name, const_data_type, const_description, const_value, var_type, const_tags\n                            )\n                            scan_stage = \"\"\n                            tmp_brief_description = \"\"\n                            tmp_detail_description = \"\"\n                            tmp_tags = []\n                            continue\n                        if line.strip().startswith(\"@export var\") \\\n                                or line.strip().startswith(\"var\") \\\n                                or line.strip().startswith(\"@onready var\"):\n                            if \"#\" in line:\n                                line = line.split(\"#\", 1)[0].strip()\n                            if line.strip().startswith(\"@export var\"):\n                                var_type = \"@export var\"\n                            if line.strip().startswith(\"var\"):\n                                var_type = \"var\"\n                            if line.strip().startswith(\"@onready var\"):\n                                var_type = \"@onready var\"\n                            var_value = None\n                            var_data_type = \"undefined\"\n                            if \"=\" in line:\n                                line, var_value = line.split(\"=\", 1)\n                                var_value = var_value.strip()\n                                line = line.strip()\n                            elif \":=\" in line:\n                                line, var_value = line.split(\":=\", 1)\n                                var_value = var_value.strip()\n                                line = line.strip()\n                            if \":\" in line:\n                                line, var_data_type = line.split(\":\", 1)\n                                var_data_type = var_data_type.strip()\n                                line = line.strip()\n                            var_name = line.replace(\"var\", \"\", 1).strip()\n                            var_name = var_name.replace(\"@onready\", \"\", 1).strip()\n                            var_name = var_name.replace(\"@export\", \"\", 1).strip()\n                            var_description = tmp_brief_description\n                            if tmp_detail_description != \"\":\n                                var_description = var_description + \"\\n\\n\" + tmp_detail_description\n                            var_tags: list[TagDoc] = []\n                            for tag in tmp_tags:\n                                tutorial_url = \"\"\n                                tutorial_name = \"\"\n                                tag_type = tag[0]\n                                if len(tag) &gt; 1:\n                                    tutorial_url = tag[1]\n                                if len(tag) &gt; 2:\n                                    tutorial_name = tag[2]\n                                var_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                            class_doc.add_attribute(\n                                var_name, var_data_type, var_description, var_value, var_type, var_tags\n                            )\n                            scan_stage = \"\"\n                            tmp_brief_description = \"\"\n                            tmp_detail_description = \"\"\n                            tmp_tags = []\n                            continue\n                        if line.strip().startswith(\"@export\"):\n                            scan_stage = \"@export\"\n                            continue\n                        if line.strip().startswith(\"@onready\"):\n                            scan_stage = \"@onready\"\n                            continue\n                        if line.strip().startswith(\"func\"):\n\n                            continue\n                        if line.strip().startswith(\"class\"):\n\n                            continue\n                        # todo: should be class docstring if nothing of the above\n                if scan_stage == \"@export\" or scan_stage == \"@onready\":\n                    if scan_stage == \"@export\":\n                        if not line.strip().startswith(\"var\"):\n                            print(\"Warning: @export is not followed by var, ignoring ...\")\n                            continue\n                        else:\n                            var_type = \"@export var\"\n                    if scan_stage == \"@onready\":\n                        if not line.strip().startswith(\"var\"):\n                            print(\"Warning: @onready is not followed by var, ignoring ...\")\n                            continue\n                        else:\n                            var_type = \"@onready var\"\n                    var_value = None\n                    var_data_type = \"undefined\"\n                    if \"=\" in line:\n                        line, var_value = line.split(\"=\", 1)\n                        var_value = var_value.strip()\n                        line = line.strip()\n                    if \":=\" in line:\n                        line, var_value = line.split(\":=\", 1)\n                        var_value = var_value.strip()\n                        line = line.strip()\n                    if \":\" in line:\n                        line, var_data_type = line.split(\":\", 1)\n                        var_data_type = var_data_type.strip()\n                        line = line.strip()\n                    var_name = line.replace(\"var\", \"\", 1).strip()\n                    var_name = var_name.replace(\"@onready\", \"\", 1).strip()\n                    var_name = var_name.replace(\"@export\", \"\", 1).strip()\n                    var_description = tmp_brief_description\n                    if tmp_detail_description != \"\":\n                        var_description = var_description + \"\\n\\n\" + tmp_detail_description\n                    var_tags: list[TagDoc] = []\n                    for tag in tmp_tags:\n                        tutorial_url = \"\"\n                        tutorial_name = \"\"\n                        tag_type = tag[0]\n                        if len(tag) &gt; 1:\n                            tutorial_url = tag[1]\n                        if len(tag) &gt; 2:\n                            tutorial_name = tag[2]\n                        var_tags.append(TagDoc(tag_type, tutorial_url, tutorial_name))\n                    class_doc.add_attribute(\n                        var_name, var_data_type, var_description, var_value, var_type, var_tags\n                    )\n                    scan_stage = \"\"\n                    tmp_brief_description = \"\"\n                    tmp_detail_description = \"\"\n                    tmp_tags = []\n                    continue\n                if scan_stage == \"enum\":\n                    line = line.strip()\n                    if \"#\" in line and \"##\" not in line:\n                        line = line.split(\"#\", 1)[0].strip()\n                    if line == \"{\" or line == \"\":\n                        continue\n                    if line.startswith(\"##\"):\n                        line = line.replace(\"##\", \"\").strip()\n                        if \"enum_member_tmp_description\" in locals():\n                            if enum_member_description != \"\" or enum_member_description is not None:\n                                enum_member_description = enum_member_description + \" \" + line\n                            else:\n                                enum_member_description = line\n                        else:\n                            enum_member_description = line\n                        continue\n                    if \"##\" in line:\n                        com, doc = line.split(\"##\")\n                        com = com.strip()\n                        doc = doc.strip\n                        if \"enum_member_tmp_description\" in locals():\n                            if enum_member_description != \"\" or enum_member_description is not None:\n                                enum_member_description = enum_member_description + \" \" + doc\n                            else:\n                                enum_member_description = doc\n                        else:\n                            enum_member_description = doc\n                        if \"=\" in line:\n                            enum_member_value_name, enum_member_value_int = line.split(\"=\")\n                            enum_member_value_name = enum_member_value_name.strip()\n                            enum_member_value_int = enum_member_value_int.strip()\n                        else:\n                            enum_member_value_name = line.strip()\n                            if len(tmp_enum_members) &lt; 1:\n                                enum_member_value_int = 0\n                            else:\n                                enum_member_value_int = tmp_enum_members[-1].value_int + 1\n                        tmp_enum_members.append(\n                            EnumMemberDoc(enum_member_value_name, enum_member_value_int, enum_member_description)\n                        )\n                        continue\n                    if \"=\" in line:\n                        enum_member_value_name, enum_member_value_int = line.split(\"=\")\n                        enum_member_value_name = enum_member_value_name.strip()\n                        enum_member_value_int = enum_member_value_int.strip()\n                    else:\n                        enum_member_value_name = line.strip()\n                        if len(tmp_enum_members) &lt; 1:\n                            enum_member_value_int = 0\n                        else:\n                            enum_member_value_int = tmp_enum_members[-1].value_int + 1\n                    tmp_enum_members.append(\n                        EnumMemberDoc(enum_member_value_name, enum_member_value_int, enum_member_description)\n                    )\n                    if line.endswith(\"}\"):\n                        # todo: add enum with members to doc\n\n                        pass\n                    continue\n                if scan_stage == \"args\":\n\n                    continue\n                if scan_stage == \"returns\":\n\n                    continue\n    except Exception as e:\n\n        # todo: broader exception handling\n        print(e)\n    return class_doc\n</code></pre>"},{"location":"src/control/settings/","title":"settings.py","text":""},{"location":"src/control/settings/#src.control.settings.Settings","title":"<code>Settings</code>","text":"<p>Class to handle the settings for reading the source.</p> <p>Attributes:</p> Name Type Description <code>doc_conf_file</code> <code>str</code> <p>The settings for reading the source are stored in this yaml file</p> <code>doc_conf_data</code> <code>[dict | CommentedMap]</code> <p>The deserialized settings for reading the sourcecode, also used as template at --init</p> <code>yaml</code> <code>YAML</code> <p>Object for loading and serializing yaml</p> Source code in <code>src/control/settings.py</code> <pre><code>class Settings:\n    \"\"\"\n    Class to handle the settings for reading the source.\n\n    Attributes:\n        doc_conf_file: The settings for reading the source are stored in this yaml file\n        doc_conf_data: The deserialized settings for reading the sourcecode, also used as template at --init\n        yaml: Object for loading and serializing yaml\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Constructor of the class, defining class attributes.\n        \"\"\"\n        self.doc_conf_file: str = \"./md_gd4_docs.yml\"\n        self.doc_conf_data: [dict | CommentedMap] = {\n            \"doc_destination\": \"\",\n            \"rebuild_src_path\": True,\n            \"project_scan\": True,\n            \"project_scan_options\": {\n                \"src_path\": \"\",\n                \"read_gd_project\": True,\n                \"scene2src_links\": True\n            },\n            \"filelist_scan\": False,\n            \"scan_list\": [\n                \"./file1.gd\",\n                \"./file2.gd\"\n            ]\n        }\n        self.yaml: YAML = YAML()\n        print(\"Application settings initialized.\")\n\n    def init_settings(self) -&gt; bool:\n        \"\"\"\n        This method writes a configuration template for how to read the project / sourcecode, if it not already exists.\n\n        Returns:\n            Result of the operation, True if creating configuration file successfully\n        \"\"\"\n        print(\"Initializing documentation settings ...\")\n        if isfile(self.doc_conf_file):\n            print(f\"Configuration file {self.doc_conf_file} already exists.\")\n            print(\"If you want start over again, you have to delete (after backup?) the file first\")\n            return False\n        try:\n            with open(self.doc_conf_file, \"w\") as file:\n                self.yaml.dump(self.doc_conf_data, file)\n                print(f\"Documentation settings template {self.doc_conf_file} successfully created.\")\n                return True\n        except Exception as e:\n            print(f\"Writing file {self.doc_conf_file} failed with Exception:\")\n            print(e)\n            return False\n\n    def load_settings(self) -&gt; bool:\n        \"\"\"\n        Loads the settings from the configuration file, if it exists, and serializes it into the doc_conf_data dict.\n\n        Returns:\n            True if loading and serializing is successful. Further checks of the correctness of the file are not done\n                here, has to be done before reading the source at the build stage\n        \"\"\"\n        print(\"Loading documentation settings ...\")\n        if not isfile(self.doc_conf_file):\n            print(f\"Configuration file {self.doc_conf_file} doesn't exist.\")\n            print(\"A settings template can be created with:\")\n            print(\"    md_gd4_docs --init\")\n            return False\n        try:\n            with open(self.doc_conf_file, \"r\") as file:\n                self.doc_conf_data = self.yaml.load(file)\n                if not self.doc_conf_data[\"doc_destination\"].endswith(\"/\"):\n                    self.doc_conf_data[\"doc_destination\"] = \\\n                        self.doc_conf_data[\"doc_destination\"] + \"/\"\n                if not self.doc_conf_data[\"project_scan_options\"][\"src_path\"].endswith(\"/\"):\n                    self.doc_conf_data[\"project_scan_options\"][\"src_path\"] = \\\n                        self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + \"/\"\n                print(f\"Documentation settings file {self.doc_conf_file} successfully loaded.\")\n                return True\n        except Exception as e:\n            print(f\"Reading file {self.doc_conf_file} failed with Exception:\")\n            print(e)\n            return False\n\n    def get_settings(self) -&gt; CommentedMap:\n        \"\"\"\n        Get the settings dict.\n\n        Returns:\n            doc_conf_data: Deserialized settings object. Further checks of the correctness of this settings object is\n                not done here, has to be done before reading the source at the build stage\n        \"\"\"\n        return CommentedMap(self.doc_conf_data)\n</code></pre>"},{"location":"src/control/settings/#src.control.settings.Settings.__init__","title":"<code>__init__()</code>","text":"<p>Constructor of the class, defining class attributes.</p> Source code in <code>src/control/settings.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor of the class, defining class attributes.\n    \"\"\"\n    self.doc_conf_file: str = \"./md_gd4_docs.yml\"\n    self.doc_conf_data: [dict | CommentedMap] = {\n        \"doc_destination\": \"\",\n        \"rebuild_src_path\": True,\n        \"project_scan\": True,\n        \"project_scan_options\": {\n            \"src_path\": \"\",\n            \"read_gd_project\": True,\n            \"scene2src_links\": True\n        },\n        \"filelist_scan\": False,\n        \"scan_list\": [\n            \"./file1.gd\",\n            \"./file2.gd\"\n        ]\n    }\n    self.yaml: YAML = YAML()\n    print(\"Application settings initialized.\")\n</code></pre>"},{"location":"src/control/settings/#src.control.settings.Settings.get_settings","title":"<code>get_settings()</code>","text":"<p>Get the settings dict.</p> <p>Returns:</p> Name Type Description <code>doc_conf_data</code> <code>CommentedMap</code> <p>Deserialized settings object. Further checks of the correctness of this settings object is not done here, has to be done before reading the source at the build stage</p> Source code in <code>src/control/settings.py</code> <pre><code>def get_settings(self) -&gt; CommentedMap:\n    \"\"\"\n    Get the settings dict.\n\n    Returns:\n        doc_conf_data: Deserialized settings object. Further checks of the correctness of this settings object is\n            not done here, has to be done before reading the source at the build stage\n    \"\"\"\n    return CommentedMap(self.doc_conf_data)\n</code></pre>"},{"location":"src/control/settings/#src.control.settings.Settings.init_settings","title":"<code>init_settings()</code>","text":"<p>This method writes a configuration template for how to read the project / sourcecode, if it not already exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Result of the operation, True if creating configuration file successfully</p> Source code in <code>src/control/settings.py</code> <pre><code>def init_settings(self) -&gt; bool:\n    \"\"\"\n    This method writes a configuration template for how to read the project / sourcecode, if it not already exists.\n\n    Returns:\n        Result of the operation, True if creating configuration file successfully\n    \"\"\"\n    print(\"Initializing documentation settings ...\")\n    if isfile(self.doc_conf_file):\n        print(f\"Configuration file {self.doc_conf_file} already exists.\")\n        print(\"If you want start over again, you have to delete (after backup?) the file first\")\n        return False\n    try:\n        with open(self.doc_conf_file, \"w\") as file:\n            self.yaml.dump(self.doc_conf_data, file)\n            print(f\"Documentation settings template {self.doc_conf_file} successfully created.\")\n            return True\n    except Exception as e:\n        print(f\"Writing file {self.doc_conf_file} failed with Exception:\")\n        print(e)\n        return False\n</code></pre>"},{"location":"src/control/settings/#src.control.settings.Settings.load_settings","title":"<code>load_settings()</code>","text":"<p>Loads the settings from the configuration file, if it exists, and serializes it into the doc_conf_data dict.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if loading and serializing is successful. Further checks of the correctness of the file are not done here, has to be done before reading the source at the build stage</p> Source code in <code>src/control/settings.py</code> <pre><code>def load_settings(self) -&gt; bool:\n    \"\"\"\n    Loads the settings from the configuration file, if it exists, and serializes it into the doc_conf_data dict.\n\n    Returns:\n        True if loading and serializing is successful. Further checks of the correctness of the file are not done\n            here, has to be done before reading the source at the build stage\n    \"\"\"\n    print(\"Loading documentation settings ...\")\n    if not isfile(self.doc_conf_file):\n        print(f\"Configuration file {self.doc_conf_file} doesn't exist.\")\n        print(\"A settings template can be created with:\")\n        print(\"    md_gd4_docs --init\")\n        return False\n    try:\n        with open(self.doc_conf_file, \"r\") as file:\n            self.doc_conf_data = self.yaml.load(file)\n            if not self.doc_conf_data[\"doc_destination\"].endswith(\"/\"):\n                self.doc_conf_data[\"doc_destination\"] = \\\n                    self.doc_conf_data[\"doc_destination\"] + \"/\"\n            if not self.doc_conf_data[\"project_scan_options\"][\"src_path\"].endswith(\"/\"):\n                self.doc_conf_data[\"project_scan_options\"][\"src_path\"] = \\\n                    self.doc_conf_data[\"project_scan_options\"][\"src_path\"] + \"/\"\n            print(f\"Documentation settings file {self.doc_conf_file} successfully loaded.\")\n            return True\n    except Exception as e:\n        print(f\"Reading file {self.doc_conf_file} failed with Exception:\")\n        print(e)\n        return False\n</code></pre>"},{"location":"src/model/class_doc/","title":"class_doc.py","text":""},{"location":"src/model/class_doc/#src.model.class_doc.ClassDoc","title":"<code>ClassDoc</code>","text":"<p>Model class for storing class documentation.</p> Source code in <code>src/model/class_doc.py</code> <pre><code>class ClassDoc:\n    \"\"\"\n    Model class for storing class documentation.\n    \"\"\"\n    def __init__(self, file_name: str, class_name: str = \"not exposed\", inner_class: bool = False):\n        \"\"\"\n        Constructor of the class documentation model.\n\n        Args:\n            file_name: Filename of the script\n            class_name: Class name, only needed to expose class for inheritance or for inner classes\n            inner_class: Is it an inner class? class_name becomes mandatory if True.\n\n        Raises:\n            Exception: If inner class True without or with invalid class_name\n        \"\"\"\n        self.file_name: str = file_name\n        self.class_name: str = class_name\n        self.is_inner_class: bool = inner_class\n        self.extends: str = \"\"\n        self.tags: list[TagDoc] = []\n        self.brief_description: str = \"\"\n        self.detail_description: str = \"\"\n        self.signal_docs: list[SignalDoc] = []\n        self.enum_docs: list[EnumDoc] = []\n        self.const_docs: list[VarDoc] = []\n        self.var_docs: list[VarDoc] = []\n        self.func_docs: list[FuncDoc] = []\n        self.inner_class_docs: list[ClassDoc] = []\n        if self.inner_class_docs and (self.class_name == \"not exposed\" or \" \" in self.class_name):\n            raise Exception(\"Inner classes needs to be named, no spaces allowed\")\n\n    def set_class_name(self, class_name: str):\n        self.class_name = class_name\n\n    def set_is_inner_class(self, value: bool):\n        self.is_inner_class = value\n\n    def set_extends(self, extends: str):\n        self.extends = extends\n\n    def add_signal(self, name: str, description: str, tags: list[TagDoc] = None):\n        \"\"\"\n        Adds a signal description item to the doc\n\n        Args:\n            name: Name of the signal\n            description: Description of the signal\n            tags: Tag(s) of the signal, if any\n        \"\"\"\n        self.signal_docs.append(SignalDoc(name, description, tags))\n\n    def add_enum(self):\n        \"\"\"\n        todo!\n        \"\"\"\n\n        pass\n\n    def add_attribute(\n            self,\n            name: str,\n            data_type: str,\n            description: str,\n            value=None,\n            var_type: str = \"var\",\n            tags: list[TagDoc] = None\n    ):\n        \"\"\"\n        Adds an attribute (var, const) item to the doc\n\n        Args:\n            name: Name of the Attribute\n            data_type: Data type of the attribute\n            description: Description of the Attribute\n            value: Value of the attribute, if any. Type of the attribute should match data_type\n            var_type: Could be \"const\", \"export_var\", \"var\" or \"onready_var\"\n            tags: Tag(s) of the signal, if any\n        \"\"\"\n        if var_type == \"const\":\n            self.const_docs.append(VarDoc(name, data_type, description, value, var_type, tags))\n        else:\n            self.var_docs.append(VarDoc(name, data_type, description, value, var_type, tags))\n</code></pre>"},{"location":"src/model/class_doc/#src.model.class_doc.ClassDoc.__init__","title":"<code>__init__(file_name, class_name='not exposed', inner_class=False)</code>","text":"<p>Constructor of the class documentation model.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Filename of the script</p> required <code>class_name</code> <code>str</code> <p>Class name, only needed to expose class for inheritance or for inner classes</p> <code>'not exposed'</code> <code>inner_class</code> <code>bool</code> <p>Is it an inner class? class_name becomes mandatory if True.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If inner class True without or with invalid class_name</p> Source code in <code>src/model/class_doc.py</code> <pre><code>def __init__(self, file_name: str, class_name: str = \"not exposed\", inner_class: bool = False):\n    \"\"\"\n    Constructor of the class documentation model.\n\n    Args:\n        file_name: Filename of the script\n        class_name: Class name, only needed to expose class for inheritance or for inner classes\n        inner_class: Is it an inner class? class_name becomes mandatory if True.\n\n    Raises:\n        Exception: If inner class True without or with invalid class_name\n    \"\"\"\n    self.file_name: str = file_name\n    self.class_name: str = class_name\n    self.is_inner_class: bool = inner_class\n    self.extends: str = \"\"\n    self.tags: list[TagDoc] = []\n    self.brief_description: str = \"\"\n    self.detail_description: str = \"\"\n    self.signal_docs: list[SignalDoc] = []\n    self.enum_docs: list[EnumDoc] = []\n    self.const_docs: list[VarDoc] = []\n    self.var_docs: list[VarDoc] = []\n    self.func_docs: list[FuncDoc] = []\n    self.inner_class_docs: list[ClassDoc] = []\n    if self.inner_class_docs and (self.class_name == \"not exposed\" or \" \" in self.class_name):\n        raise Exception(\"Inner classes needs to be named, no spaces allowed\")\n</code></pre>"},{"location":"src/model/class_doc/#src.model.class_doc.ClassDoc.add_attribute","title":"<code>add_attribute(name, data_type, description, value=None, var_type='var', tags=None)</code>","text":"<p>Adds an attribute (var, const) item to the doc</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Attribute</p> required <code>data_type</code> <code>str</code> <p>Data type of the attribute</p> required <code>description</code> <code>str</code> <p>Description of the Attribute</p> required <code>value</code> <p>Value of the attribute, if any. Type of the attribute should match data_type</p> <code>None</code> <code>var_type</code> <code>str</code> <p>Could be \"const\", \"export_var\", \"var\" or \"onready_var\"</p> <code>'var'</code> <code>tags</code> <code>list[TagDoc]</code> <p>Tag(s) of the signal, if any</p> <code>None</code> Source code in <code>src/model/class_doc.py</code> <pre><code>def add_attribute(\n        self,\n        name: str,\n        data_type: str,\n        description: str,\n        value=None,\n        var_type: str = \"var\",\n        tags: list[TagDoc] = None\n):\n    \"\"\"\n    Adds an attribute (var, const) item to the doc\n\n    Args:\n        name: Name of the Attribute\n        data_type: Data type of the attribute\n        description: Description of the Attribute\n        value: Value of the attribute, if any. Type of the attribute should match data_type\n        var_type: Could be \"const\", \"export_var\", \"var\" or \"onready_var\"\n        tags: Tag(s) of the signal, if any\n    \"\"\"\n    if var_type == \"const\":\n        self.const_docs.append(VarDoc(name, data_type, description, value, var_type, tags))\n    else:\n        self.var_docs.append(VarDoc(name, data_type, description, value, var_type, tags))\n</code></pre>"},{"location":"src/model/class_doc/#src.model.class_doc.ClassDoc.add_enum","title":"<code>add_enum()</code>","text":"<p>todo!</p> Source code in <code>src/model/class_doc.py</code> <pre><code>def add_enum(self):\n    \"\"\"\n    todo!\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"src/model/class_doc/#src.model.class_doc.ClassDoc.add_signal","title":"<code>add_signal(name, description, tags=None)</code>","text":"<p>Adds a signal description item to the doc</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the signal</p> required <code>description</code> <code>str</code> <p>Description of the signal</p> required <code>tags</code> <code>list[TagDoc]</code> <p>Tag(s) of the signal, if any</p> <code>None</code> Source code in <code>src/model/class_doc.py</code> <pre><code>def add_signal(self, name: str, description: str, tags: list[TagDoc] = None):\n    \"\"\"\n    Adds a signal description item to the doc\n\n    Args:\n        name: Name of the signal\n        description: Description of the signal\n        tags: Tag(s) of the signal, if any\n    \"\"\"\n    self.signal_docs.append(SignalDoc(name, description, tags))\n</code></pre>"},{"location":"src/model/enum_doc/","title":"enum_doc.py","text":""},{"location":"src/model/enum_doc/#src.model.enum_doc.EnumDoc","title":"<code>EnumDoc</code>","text":"<p>Model class for storing enum documentation (including enum members)</p> Source code in <code>src/model/enum_doc.py</code> <pre><code>class EnumDoc:\n    \"\"\"\n    Model class for storing enum documentation (including enum members)\n    \"\"\"\n    def __init__(self, name: str, description: str, tags: list[TagDoc] = None):\n        \"\"\"\n        Constructor of the enum documentation model\n\n        Args:\n            name: Name of the enum\n            description: Description of the enum\n        \"\"\"\n        self.name: str = name\n        self.description: str = description\n        if tags is None:\n            self.tags: list[TagDoc] = []\n        else:\n            self.tags: list[TagDoc] = tags\n        self.members: list[EnumMemberDoc] = []\n</code></pre>"},{"location":"src/model/enum_doc/#src.model.enum_doc.EnumDoc.__init__","title":"<code>__init__(name, description, tags=None)</code>","text":"<p>Constructor of the enum documentation model</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the enum</p> required <code>description</code> <code>str</code> <p>Description of the enum</p> required Source code in <code>src/model/enum_doc.py</code> <pre><code>def __init__(self, name: str, description: str, tags: list[TagDoc] = None):\n    \"\"\"\n    Constructor of the enum documentation model\n\n    Args:\n        name: Name of the enum\n        description: Description of the enum\n    \"\"\"\n    self.name: str = name\n    self.description: str = description\n    if tags is None:\n        self.tags: list[TagDoc] = []\n    else:\n        self.tags: list[TagDoc] = tags\n    self.members: list[EnumMemberDoc] = []\n</code></pre>"},{"location":"src/model/enum_member_doc/","title":"enum_member_doc.py","text":""},{"location":"src/model/enum_member_doc/#src.model.enum_member_doc.EnumMemberDoc","title":"<code>EnumMemberDoc</code>","text":"<p>Model class for storing enum members</p> Source code in <code>src/model/enum_member_doc.py</code> <pre><code>class EnumMemberDoc:\n    \"\"\"\n    Model class for storing enum members\n    \"\"\"\n    def __init__(self, value_name: str, value_int: int, description: str, tags: list[TagDoc] = None):\n        \"\"\"\n        Constructor of the enum member documentation model\n\n        Args:\n            value_name: Name of the enum member\n            value_int: Value of the enum member\n            description: Description of the enum member\n        \"\"\"\n\n        self.value_name = value_name\n        self.value_int = value_int\n        if tags is None:\n            self.tags: list[TagDoc] = []\n        else:\n            self.tags: list[TagDoc] = tags\n        self.description = description\n</code></pre>"},{"location":"src/model/enum_member_doc/#src.model.enum_member_doc.EnumMemberDoc.__init__","title":"<code>__init__(value_name, value_int, description, tags=None)</code>","text":"<p>Constructor of the enum member documentation model</p> <p>Parameters:</p> Name Type Description Default <code>value_name</code> <code>str</code> <p>Name of the enum member</p> required <code>value_int</code> <code>int</code> <p>Value of the enum member</p> required <code>description</code> <code>str</code> <p>Description of the enum member</p> required Source code in <code>src/model/enum_member_doc.py</code> <pre><code>def __init__(self, value_name: str, value_int: int, description: str, tags: list[TagDoc] = None):\n    \"\"\"\n    Constructor of the enum member documentation model\n\n    Args:\n        value_name: Name of the enum member\n        value_int: Value of the enum member\n        description: Description of the enum member\n    \"\"\"\n\n    self.value_name = value_name\n    self.value_int = value_int\n    if tags is None:\n        self.tags: list[TagDoc] = []\n    else:\n        self.tags: list[TagDoc] = tags\n    self.description = description\n</code></pre>"},{"location":"src/model/func_doc/","title":"func_doc.py","text":""},{"location":"src/model/func_doc/#src.model.func_doc.FuncDoc","title":"<code>FuncDoc</code>","text":"<p>Model class for holding documentation for functions</p> Source code in <code>src/model/func_doc.py</code> <pre><code>class FuncDoc:\n    \"\"\"\n    Model class for holding documentation for functions\n    \"\"\"\n    def __init__(self, name: str, description: str, args: list[VarDoc], tags: list[TagDoc] = None):\n        \"\"\"\n        Constructor of the function documentation model.\n\n        Args:\n            name: Name of the function\n            description: Description of the function\n            args: Argument(s) list of the function\n        \"\"\"\n        self.name = name\n        if tags is None:\n            self.tags: list[TagDoc] = []\n        else:\n            self.tags: list[TagDoc] = tags\n        self.description = description\n        self.args = args\n</code></pre>"},{"location":"src/model/func_doc/#src.model.func_doc.FuncDoc.__init__","title":"<code>__init__(name, description, args, tags=None)</code>","text":"<p>Constructor of the function documentation model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the function</p> required <code>description</code> <code>str</code> <p>Description of the function</p> required <code>args</code> <code>list[VarDoc]</code> <p>Argument(s) list of the function</p> required Source code in <code>src/model/func_doc.py</code> <pre><code>def __init__(self, name: str, description: str, args: list[VarDoc], tags: list[TagDoc] = None):\n    \"\"\"\n    Constructor of the function documentation model.\n\n    Args:\n        name: Name of the function\n        description: Description of the function\n        args: Argument(s) list of the function\n    \"\"\"\n    self.name = name\n    if tags is None:\n        self.tags: list[TagDoc] = []\n    else:\n        self.tags: list[TagDoc] = tags\n    self.description = description\n    self.args = args\n</code></pre>"},{"location":"src/model/signal_doc/","title":"signal_doc.py","text":""},{"location":"src/model/signal_doc/#src.model.signal_doc.SignalDoc","title":"<code>SignalDoc</code>","text":"<p>Model class for holding documentation for signals.</p> Source code in <code>src/model/signal_doc.py</code> <pre><code>class SignalDoc:\n    \"\"\"\n    Model class for holding documentation for signals.\n    \"\"\"\n    def __init__(self, name: str, description: str, tags: list[TagDoc] = None):\n        \"\"\"\n        Constructor of the signal documentation model.\n\n        Args:\n            name: Name of the signal\n            description: Description of the signal\n            tags: Tag(s) of the signal, if any\n        \"\"\"\n        self.name: str = name\n        if tags is None:\n            self.tags: list[TagDoc] = []\n        else:\n            self.tags: list[TagDoc] = tags\n        self.description: str = description\n</code></pre>"},{"location":"src/model/signal_doc/#src.model.signal_doc.SignalDoc.__init__","title":"<code>__init__(name, description, tags=None)</code>","text":"<p>Constructor of the signal documentation model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the signal</p> required <code>description</code> <code>str</code> <p>Description of the signal</p> required <code>tags</code> <code>list[TagDoc]</code> <p>Tag(s) of the signal, if any</p> <code>None</code> Source code in <code>src/model/signal_doc.py</code> <pre><code>def __init__(self, name: str, description: str, tags: list[TagDoc] = None):\n    \"\"\"\n    Constructor of the signal documentation model.\n\n    Args:\n        name: Name of the signal\n        description: Description of the signal\n        tags: Tag(s) of the signal, if any\n    \"\"\"\n    self.name: str = name\n    if tags is None:\n        self.tags: list[TagDoc] = []\n    else:\n        self.tags: list[TagDoc] = tags\n    self.description: str = description\n</code></pre>"},{"location":"src/model/tag_doc/","title":"tag_doc.py","text":""},{"location":"src/model/tag_doc/#src.model.tag_doc.TagDoc","title":"<code>TagDoc</code>","text":"<p>Model class for holding documentation for tags</p> Source code in <code>src/model/tag_doc.py</code> <pre><code>class TagDoc:\n    \"\"\"\n    Model class for holding documentation for tags\n    \"\"\"\n    def __init__(self, tag_type: str, tutorial_url: str = \"\", tutorial_name: str = \"\"):\n        \"\"\"\n        Constructor of the tag documentation model.\n\n        Args:\n            tag_type: Possible values are \"@tutorial\", \"@experimental\" or \"@deprecated\"\n            tutorial_url: Only used for @tutorial tag\n            tutorial_name: Only used for @tutorial tag\n\n        Raises:\n            Exception: If tag_type invalid\n        \"\"\"\n        self.tag_type = tag_type\n        self.tutorial_url = tutorial_url\n        self.tutorial_name = tutorial_name\n        if self.tag_type != \"@tutorial\" \\\n                or self.tag_type != \"@experimental\" \\\n                or self.tag_type != \"@deprecated\":\n            raise Exception('Only \"@tutorial\", \"@experimental\" or \"@deprecated\" are valid tag types')\n</code></pre>"},{"location":"src/model/tag_doc/#src.model.tag_doc.TagDoc.__init__","title":"<code>__init__(tag_type, tutorial_url='', tutorial_name='')</code>","text":"<p>Constructor of the tag documentation model.</p> <p>Parameters:</p> Name Type Description Default <code>tag_type</code> <code>str</code> <p>Possible values are \"@tutorial\", \"@experimental\" or \"@deprecated\"</p> required <code>tutorial_url</code> <code>str</code> <p>Only used for @tutorial tag</p> <code>''</code> <code>tutorial_name</code> <code>str</code> <p>Only used for @tutorial tag</p> <code>''</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If tag_type invalid</p> Source code in <code>src/model/tag_doc.py</code> <pre><code>def __init__(self, tag_type: str, tutorial_url: str = \"\", tutorial_name: str = \"\"):\n    \"\"\"\n    Constructor of the tag documentation model.\n\n    Args:\n        tag_type: Possible values are \"@tutorial\", \"@experimental\" or \"@deprecated\"\n        tutorial_url: Only used for @tutorial tag\n        tutorial_name: Only used for @tutorial tag\n\n    Raises:\n        Exception: If tag_type invalid\n    \"\"\"\n    self.tag_type = tag_type\n    self.tutorial_url = tutorial_url\n    self.tutorial_name = tutorial_name\n    if self.tag_type != \"@tutorial\" \\\n            or self.tag_type != \"@experimental\" \\\n            or self.tag_type != \"@deprecated\":\n        raise Exception('Only \"@tutorial\", \"@experimental\" or \"@deprecated\" are valid tag types')\n</code></pre>"},{"location":"src/model/var_doc/","title":"var_doc.py","text":""},{"location":"src/model/var_doc/#src.model.var_doc.VarDoc","title":"<code>VarDoc</code>","text":"<p>Model class for holding documentation for a var or const.</p> Source code in <code>src/model/var_doc.py</code> <pre><code>class VarDoc:\n    \"\"\"\n    Model class for holding documentation for a var or const.\n    \"\"\"\n\n    def __init__(\n            self,\n            name: str,\n            data_type: str,\n            description: str,\n            value=None,\n            var_type: str = \"var\",\n            tags: list[TagDoc] = None\n    ):\n        \"\"\"\n        Constructor of the const documentation model.\n\n        Args:\n            name: Name of the const\n            data_type: Data type of the const\n            description: Description of the const\n            value: Should have data type as mentioned in data_type\n            var_type: Could be \"const\", \"export_var\", \"var\" or \"onready_var\"\n            tags: Tag(s) of the signal, if any\n        \"\"\"\n        self.name: str = name\n        self.data_type: str = data_type\n        if tags is None:\n            self.tags: list[TagDoc] = []\n        else:\n            self.tags: list[TagDoc] = tags\n        self.description: str = description\n        self.value = value\n        self.var_type: str = var_type\n        if self.var_type != \"const\" \\\n                or self.var_type != \"export_var\" \\\n                or self.var_type != \"var\" \\\n                or self.var_type != \"onready_var\":\n            raise Exception('Only \"const\", \"export_var\", \"var\" or \"onready_var\" are valid var types')\n</code></pre>"},{"location":"src/model/var_doc/#src.model.var_doc.VarDoc.__init__","title":"<code>__init__(name, data_type, description, value=None, var_type='var', tags=None)</code>","text":"<p>Constructor of the const documentation model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the const</p> required <code>data_type</code> <code>str</code> <p>Data type of the const</p> required <code>description</code> <code>str</code> <p>Description of the const</p> required <code>value</code> <p>Should have data type as mentioned in data_type</p> <code>None</code> <code>var_type</code> <code>str</code> <p>Could be \"const\", \"export_var\", \"var\" or \"onready_var\"</p> <code>'var'</code> <code>tags</code> <code>list[TagDoc]</code> <p>Tag(s) of the signal, if any</p> <code>None</code> Source code in <code>src/model/var_doc.py</code> <pre><code>def __init__(\n        self,\n        name: str,\n        data_type: str,\n        description: str,\n        value=None,\n        var_type: str = \"var\",\n        tags: list[TagDoc] = None\n):\n    \"\"\"\n    Constructor of the const documentation model.\n\n    Args:\n        name: Name of the const\n        data_type: Data type of the const\n        description: Description of the const\n        value: Should have data type as mentioned in data_type\n        var_type: Could be \"const\", \"export_var\", \"var\" or \"onready_var\"\n        tags: Tag(s) of the signal, if any\n    \"\"\"\n    self.name: str = name\n    self.data_type: str = data_type\n    if tags is None:\n        self.tags: list[TagDoc] = []\n    else:\n        self.tags: list[TagDoc] = tags\n    self.description: str = description\n    self.value = value\n    self.var_type: str = var_type\n    if self.var_type != \"const\" \\\n            or self.var_type != \"export_var\" \\\n            or self.var_type != \"var\" \\\n            or self.var_type != \"onready_var\":\n        raise Exception('Only \"const\", \"export_var\", \"var\" or \"onready_var\" are valid var types')\n</code></pre>"},{"location":"userdoc/","title":"User manual","text":""}]}